///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V6.30.1.934/W32 for MSP430          12/Oct/2020  03:29:56
// Copyright 1996-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
//
//    __rt_version  =  3
//    __double_size =  32
//    __reg_r4      =  free
//    __reg_r5      =  free
//    __pic         =  no
//    __core        =  430X
//    __data_model  =  large
//    __code_model  =  large
//    Source file   =  
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\msp430f5529_timer.c
//    Command line  =  
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\msp430f5529_timer.c
//        -D DEBUG -D RAM_VECTOR -lA
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Debug\List\ -o
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Debug\Obj\ --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
//        -D__MSP430F5529__ -e --double=32 --dlib_config "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.2\430\lib\dlib\dl430xllff.h"
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\inc\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_config\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_User\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\srcUSB\USB_API\USB_CDC_API\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_API\USB_HID_API\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_API\USB_MSC_API\
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\delay\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\18b20\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\KEY\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\LED\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\12864\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\oled\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\mpu6050\inc\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\mpu6050\src\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nokia5110\inc\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nokia5110\src\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\LQ_1.8_TFT\
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\LCD_API\
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\2.2TFT\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nrf24l01\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\System\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\System\inc\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\System\src\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\User\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\User\USER\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\UCOSII\CONFIG\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\uCOSII\App\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\uCOSII\CONFIHG\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\uCOSII\PORT\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\UCOSII\CORE\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\FatFs\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\FatFs\option\ -I
//        G:\比赛\2020电赛\MSP430F5529库函数2.6\MSP430F5529库函数2.6\C版\工程模板\User\USER\
//        --core=430X --data_model=large -On --multiplier=32
//        --hw_workaround=CPU40 --code_model=large
//    List file     =  
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Debug\List\msp430f5529_timer.s43
//
///////////////////////////////////////////////////////////////////////////////

        NAME msp430f5529_timer

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__code_model", "large"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?Mul32
        EXTERN ?DivMod32u
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC TIMERX
        PUBLIC TIMER_CHANEL_PIN
        PUBLIC TIMER_CLK_PIN
        PUBLIC TIMER_Capture_CalTime_Us
        PUBLIC TIMER_Capture_Clear
        PUBLIC TIMER_Capture_GetValue
        PUBLIC TIMER_Capture_Init
        PUBLIC TIMER_Capture_SetMode
        PUBLIC TIMER_ClearITPendingBit
        PUBLIC TIMER_Delay_Us
        PUBLIC TIMER_GetChannelCounterValue
        PUBLIC TIMER_GetChannelPinInValue
        PUBLIC TIMER_GetChannelPinOutValue
        PUBLIC TIMER_GetCounterValue
        PUBLIC TIMER_GetITStatus
        PUBLIC TIMER_ITConfig
        PUBLIC TIMER_Interval_Us
        PUBLIC TIMER_PRECISON
        PUBLIC TIMER_PWM_MultiChannel_Init
        PUBLIC TIMER_PWM_SetChannelDuty
        PUBLIC TIMER_PWM_SetChannelOutmod
        PUBLIC TIMER_PWM_SetFrequency
        PUBLIC TIMER_Pluse_Clear
        PUBLIC TIMER_Pluse_GetValue
        PUBLIC TIMER_Pluse_Init
        PUBLIC TIMER_Run
        PUBLIC TIMER_SetChannelCounterValue
        PUBLIC TIMER_SetCounterValue
        PUBLIC TIMER_Stop
        PUBLIC TIMER_Timer_GetTime_Us
        PUBLIC TIMER_Timer_Init
        PUBLIC TIMER_Timer_Start
        PUBLIC TIMER_Timer_Stop
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN assert_failed
        EXTERN _Cast32uto32f
        EXTERN g_sClock
        EXTERN _Div32f
        EXTERN _Cast32fto32u
        EXTERN GPIO_MultiBits_Init
        EXTERN _Mul32f


        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`:
        DC8 47H, 3AH, 5CH, 0B1H, 0C8H, 0C8H, 0FCH, 5CH
        DC8 32H, 30H, 32H, 30H, 0B5H, 0E7H, 0C8H, 0FCH
        DC8 5CH, 0B4H, 0FAH, 0C2H, 0EBH, 5CH, 4DH, 53H
        DC8 50H, 34H, 33H, 30H, 5CH, 0B2H, 0E2H, 0CAH
        DC8 0D4H, 0B9H, 0A6H, 0C4H, 0DCH, 5CH, 0B9H, 0A4H
        DC8 0B3H, 0CCH, 0C4H, 0A3H, 0B0H, 0E5H, 5CH, 44H
        DC8 72H, 69H, 76H, 65H, 72H, 73H, 5CH, 73H
        DC8 72H, 63H, 5CH, 6DH, 73H, 70H, 34H, 33H
        DC8 30H, 66H, 35H, 35H, 32H, 39H, 5FH, 74H
        DC8 69H, 6DH, 65H, 72H, 2EH, 63H, 0

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_PWM_MultiChanne...">`:
        DC8 "TIMER_PWM_MultiChannel_Init"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`:
        DC8 "\266\250\312\261\306\367\315\250\265\300\262\316\312\375\263\254\263\366\267\266\316\247\243\241"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_PWM_SetChannelDuty">`:
        DC8 "TIMER_PWM_SetChannelDuty"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "\\266\\250\\312\\261\\306\\367\\325\\274\\2`:
        DC8 "\266\250\312\261\306\367\325\274\277\325\261\310\262\316\312\375\263\254\263\366\267\266\316\247\243\241"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_Capture_Init">`:
        DC8 "TIMER_Capture_Init"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_Capture_Clear">`:
        DC8 "TIMER_Capture_Clear"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_Capture_GetValue">`:
        DC8 "TIMER_Capture_GetValue"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_GetChannelCount...">`:
        DC8 "TIMER_GetChannelCounterValue"

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "TIMER_SetChannelCount...">`:
        DC8 "TIMER_SetChannelCounterValue"
// G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\msp430f5529_timer.c
//    1 #include "msp430f5529_timer.h"
//    2 #include "msp430f5529_clock.h"
//    3 #include "msp430f5529_gpio.h"
//    4 #include "msp430f5529_system.h"
//    5 #include "stdarg.h"
//    6 
//    7 //定义4个指针数组保存 TIMERX 的地址

        RSEG DATA20_C:CONST:SORT:NOROOT(1)
//    8 const TIMER_MemMapPtr TIMERX[TIMER_NUM] ={TIMER_A0_BASE_PTR,TIMER_A1_BASE_PTR,TIMER_A2_BASE_PTR,TIMER_B0_BASE_PTR};
TIMERX:
        DC32 340H, 380H, 400H, 3C0H
//    9 //定义数组保存占空比最大值

        RSEG DATA20_C:CONST:SORT:NOROOT(1)
//   10 const uint32_t TIMER_PRECISON[TIMER_NUM]={TIMER_PWM_A0_PRECISON,TIMER_PWM_A1_PRECISON,TIMER_PWM_A2_PRECISON,TIMER_PWM_B0_PRECISON};
TIMER_PRECISON:
        DC32 1000, 1000, 1000, 20000
//   11 //定义通道引脚

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
//   12 const GPIO_PIN TIMER_CHANEL_PIN[TIMER_NUM][TIMER_CH_NUM]=
TIMER_CHANEL_PIN:
        DC8 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 0, 0, 0, 0, 7, 1, 0, 1, 1, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 1, 3, 1, 4, 1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 4, 7
        DC8 6, 4, 6, 5, 6, 6, 2, 5, 2, 6
//   13 {// CH0    CH1    CH2    CH3    CH4    CH5    CH6
//   14   {{P1,1},{P1,2},{P1,3},{P1,4},{P1,5}},                  //TIMER_A0
//   15   {{P1,7},{P2,0},{P2,1}},                                //TIMER_A1
//   16   {{P2,3},{P2,4},{P2,5}},                                //TIMER_A2
//   17   {{P5,6},{P5,7},{P7,4},{P7,5},{P7,6},{P3,5},{P3,6}}     //TIMER_B0
//   18 };//通道引脚

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
//   19 const GPIO_PIN TIMER_CLK_PIN[TIMER_NUM] =
TIMER_CLK_PIN:
        DC8 0, 0, 0, 6, 1, 2, 6, 7
//   20 {
//   21   {P1,0},                                                //TIMER_A0
//   22   {P1,6},                                                //TIMER_A1
//   23   {P2,2},                                                //TIMER_A2
//   24   {P7,7}                                                 //TIMER_B0
//   25 };//外部时钟输入引脚
//   26 /*******************************************************************************
//   27 *  函数名称：TIMER_PWM_MultiChannel_Init(TIMERn timer, uint32_t fre, uint8_t ChannelNum,...)
//   28 *  功能说明：定时器PWM输出初始化(可以多个通道同时初始化)
//   29 *  参数说明：TIMERn timer       ：定时器模块
//   30              uint32_t fre         ：频率
//   31              uint8_t ChannelNum   ：要初始化的通道数
//   32              ...                ：初始化的通道
//   33 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//   34 *  使用例程：实例一：（使用函数初始化时需要输入初始化通道数，初始化通道数可以为0，如：TIMER_PWM_MultiChannel_Init(TIMER_A0, 1000, 0);）
//   35              TIMER_PWM_MultiChannel_Init(TIMER_A0, 1000, 3, TIMER_CH1, TIMER_CH2, TIMER_CH4);
//   36              //定时器TIMER_A0初始化输出PWM波，频率为1000Hz,初始化3个通道，分别是：TIMER_CH1,TIMER_CH2,TIMER_CH4
//   37              实例二：(使用宏定义初始化时不需要输入初始化通道数)
//   38              TIMER_PWM_Init(TIMER_B0,1000,TIMER_CH1,TIMER_CH2,TIMER_CH3,TIMER_CH4,TIMER_CH5,TIMER_CH6);
//   39              //定时器TIMER_B0初始化输出PWM波，频率为1000Hz,初始化6个通道：TIMER_CH1,TIMER_CH2,TIMER_CH3,TIMER_CH4,TIMER_CH5,TIMER_CH6
//   40 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   41 STATUS TIMER_PWM_MultiChannel_Init(TIMERn timer, uint32_t fre, uint8_t ChannelNum,...)
TIMER_PWM_MultiChannel_Init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function TIMER_PWM_MultiChannel_Init
//   42 {
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        SUB.W   #0x4, SP
          CFI CFA SP+40
        MOV.B   R12, R10
        MOV.W   R14, R6
        MOV.W   R15, R7
        MOV.B   R13, R8
//   43 #ifdef DELAY_TIMER
//   44   ASSERT((timer != DELAY_TIMER),
//   45          "TIMER_PWM_MultiChannel_Init",
//   46          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//   47 #endif
//   48   ASSERT((timer==TIMER_A0&&ChannelNum<=TIMER_CH4)
//   49        ||(timer==TIMER_A1&&ChannelNum<=TIMER_CH2)
//   50        ||(timer==TIMER_A2&&ChannelNum<=TIMER_CH2)
//   51        ||(timer==TIMER_B0&&ChannelNum<=TIMER_CH6),
//   52        "TIMER_PWM_MultiChannel_Init",
//   53        "定时器通道参数超出范围！"); //断言检测输入参数*/
        CMP.B   #0x0, R10
        JNE     ??TIMER_PWM_MultiChannel_Init_1
        CMP.B   #0x5, R8
        JNC     ??TIMER_PWM_MultiChannel_Init_2
??TIMER_PWM_MultiChannel_Init_1:
        CMP.B   #0x1, R10
        JNE     ??TIMER_PWM_MultiChannel_Init_3
        CMP.B   #0x3, R8
        JNC     ??TIMER_PWM_MultiChannel_Init_2
??TIMER_PWM_MultiChannel_Init_3:
        CMP.B   #0x2, R10
        JNE     ??TIMER_PWM_MultiChannel_Init_4
        CMP.B   #0x3, R8
        JNC     ??TIMER_PWM_MultiChannel_Init_2
??TIMER_PWM_MultiChannel_Init_4:
        CMP.B   #0x3, R10
        JNE     ??TIMER_PWM_MultiChannel_Init_5
        CMP.B   #0x7, R8
        JNC     ??TIMER_PWM_MultiChannel_Init_2
??TIMER_PWM_MultiChannel_Init_5:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_PWM_MultiChanne...">`, R14
        MOV.W   #0x35, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//   54   
//   55   va_list ap;
//   56   va_start(ap,ChanelNum);
??TIMER_PWM_MultiChannel_Init_2:
        MOV.W   SP, R15
        ADD.W   #0x28, R15
        MOVA    R15, 0(SP)
//   57   for(int i=0;i < ChannelNum;i++)           //根据初始化的通道数，逐一初始化通道
        MOV.W   #0x0, R9
??TIMER_PWM_MultiChannel_Init_0:
        MOV.B   R8, R8
        CMP.W   R8, R9
        JGE     ??TIMER_PWM_MultiChannel_Init_6
//   58   {
//   59     TIMER_CHn ch = va_arg(ap, TIMER_CHn);  //读取要初始化的通道
        ADDX.A  #0x2, 0(SP)
        MOVA    @SP, R15
        MOVX.B  0xffffe(R15), R11
//   60     if((ch == TIMER_CH0) || (ch >= TIMER_CH_NUM))   //判断通道值是否合理
        CMP.B   #0x0, R11
        JEQ     ??TIMER_PWM_MultiChannel_Init_7
        CMP.B   #0x7, R11
        JNC     ??TIMER_PWM_MultiChannel_Init_8
//   61     {
//   62       return ERROR;                                 //不合理返回ERROR
??TIMER_PWM_MultiChannel_Init_7:
        MOV.B   #0x0, R12
        JMP     ??TIMER_PWM_MultiChannel_Init_9
//   63     }
//   64     //初始化端口
//   65     GPIO_Init(TIMER_CHANEL_PIN[timer][ch].Port,TIMER_CHANEL_PIN[timer][ch].Pin,GPO|SEL);
??TIMER_PWM_MultiChannel_Init_8:
        MOV.W   #0x102, R14
        MOV.W   #0x1, R13
        MOV.B   R11, R15
        ADDA    R15, R15
        MOV.B   R10, R12
        ADDA    R12, R12
        MOVA    R12, R4
        ADDA    R12, R12
        ADDA    R12, R4
        ADDA    R12, R12
        ADDA    R4, R12
        MOVA    R12, R4
        ADDA    R4, R15
        MOVX.B  TIMER_CHANEL_PIN + 1(R15), R15
        SUB.B   #0x1, R15
        JN      ??TIMER_PWM_MultiChannel_Init_10
        RPT     R15
        RLAX.W  R13
??TIMER_PWM_MultiChannel_Init_10:
        ADD.B   #0x1, R15
        MOV.B   R10, R15
        ADDA    R15, R15
        MOVA    R15, R4
        ADDA    R15, R15
        ADDA    R15, R4
        ADDA    R15, R15
        ADDA    R4, R15
        MOV.B   R11, R12
        ADDA    R12, R12
        MOVA    R12, R4
        ADDA    R4, R15
        MOVX.B  TIMER_CHANEL_PIN(R15), R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//   66     //初始化占空比及输出波形
//   67     TIMERX[timer]->CCR[ch] = 0u;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        MOV.W   #0x0, 0x12(R15)
//   68     TIMERX[timer]->CCTL[ch].IE = RESET;               //关闭通道中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        BIC.W   #0x10, 0x2(R15)
//   69     TIMERX[timer]->CCTL[ch].OUTMOD = DEFAULT_PWM_OUTMOD;      //输出波形设置
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        BIS.W   #0xe0, 0x2(R15)
//   70     TIMERX[timer]->CCTL[ch].CAPMODE = RESET;          //比较模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R11
        ADDA    R11, R11
        MOVA    R11, R14
        ADDA    R14, R15
        BIC.W   #0x100, 0x2(R15)
//   71   }
        ADD.W   #0x1, R9
        JMP     ??TIMER_PWM_MultiChannel_Init_0
//   72   va_end(ap);
//   73   
//   74   return TIMER_PWM_SetFrequency(timer,fre);
??TIMER_PWM_MultiChannel_Init_6:
        MOV.W   R6, R14
        MOV.W   R7, R15
        MOV.B   R10, R12
          CFI FunCall TIMER_PWM_SetFrequency
        CALLA   #TIMER_PWM_SetFrequency
??TIMER_PWM_MultiChannel_Init_9:
        ADD.W   #0x4, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//   75 }
//   76 /*******************************************************************************
//   77 *  函数名称：TIMER_PWM_SetChannelOutmod(TIMERn timer,TIMER_CHn ch,TIMER_OUTMODn outmod)
//   78 *  功能说明：PWM输出波形设置
//   79 *  参数说明：TIMERn timer       ：定时器模块
//   80              TIMER_CHn ch       ：定时器通道
//   81              TIMER_PWM_OUTMODn outmod ：输出波形模式
//   82 *  函数返回：无
//   83 *  使用例程：TIMER_PWM_SetChannelOutmod(TIMER_A0,TIMER_CH1,TIMER_PWM_OUTMOD3);  //修改定时器A0的TIMER_CH1通道输出波形
//   84 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   85 void TIMER_PWM_SetChannelOutmod(TIMERn timer,TIMER_CHn ch,TIMER_PWM_OUTMODn outmod)
TIMER_PWM_SetChannelOutmod:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function TIMER_PWM_SetChannelOutmod
          CFI NoCalls
//   86 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
//   87   TIMERX[timer]->CCTL[ch].OUTMOD = outmod;      //输出波形设置
        MOV.B   R14, R15
        RPT     #0x5
        RLAX.W  R15
        AND.W   #0xe0, R15
        MOV.B   R12, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R11
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R8
        ADDA    R8, R11
        MOV.W   0x2(R11), R11
        AND.W   #0xff1f, R11
        BIS.W   R15, R11
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R8
        ADDA    R8, R15
        MOV.W   R11, 0x2(R15)
//   88 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//   89 /*******************************************************************************
//   90 *  函数名称：TIMER_PWM_SetFrequency(TIMERn timer,uint32_t fre)
//   91 *  功能说明：定时器PWM频率设置(注意这里没有更改各个通道的占空比，所以修改频率后占空比变了，需要从新设置占空比)
//   92 *  参数说明：TIMERn timer       ：定时器模块
//   93              uint32_t fre         ：频率
//   94 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//   95 *  使用例程：TIMER_PWM_SetFrequency(TIMER_B0,1000);       //将定时器B输出频率修改为1000Hz
//   96 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   97 STATUS  TIMER_PWM_SetFrequency(TIMERn timer,uint32_t fre)
TIMER_PWM_SetFrequency:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function TIMER_PWM_SetFrequency
//   98 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R8
        MOV.W   R14, R6
        MOV.W   R15, R7
//   99   if(fre == 0u)
        MOV.W   R6, R15
        BIS.W   R7, R15
        CMP.W   #0x0, R15
        JNE     ??TIMER_PWM_SetFrequency_1
//  100   {
//  101     TIMERX[timer]->MC = TIMER_MC_STOP;              //暂停输出PWM波
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xffcf, 0(R15)
//  102     return SUCCESS;
        MOV.B   #0x1, R12
        JMP     ??TIMER_PWM_SetFrequency_2
//  103   }
//  104   
//  105   TIMERX[timer]->CLR = BIT_SET;
??TIMER_PWM_SetFrequency_1:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  106   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;           //先选择时钟源为SMCLK
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R8, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.W   R15, 0(R11)
//  107   TIMERX[timer]->ID = 0u;                           //分频系数清零
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  108   //时钟大小
//  109   uint32_t Counter_Value = g_sClock.SMCLK.nHZ/fre;                 //计算计数值
        MOVX.W  &g_sClock + 12, R12
        MOVX.W  &g_sClock + 14, R13
        MOV.W   R6, R14
        MOV.W   R7, R15
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        MOV.W   R12, R10
        MOV.W   R13, R11
//  110   while(Counter_Value > 65536u)        //这里不是0xffff，因为后面会-1，所以是(0xffff+1)=65536
??TIMER_PWM_SetFrequency_0:
        CMP.W   #0x1, R11
        JNC     ??TIMER_PWM_SetFrequency_3
        JNE     ??TIMER_PWM_SetFrequency_4
        CMP.W   #0x1, R10
        JNC     ??TIMER_PWM_SetFrequency_3
//  111   {  //分频一次
//  112      TIMERX[timer]->ID ++;          
??TIMER_PWM_SetFrequency_4:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        PUSH.W  R14
          CFI CFA SP+30
        MOV.B   R15, 0(SP)
        POP.W   R14
          CFI CFA SP+28
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        ADD.W   #0x1, R14
        RPT     #0x6
        RLAX.W  R14
        AND.W   #0xc0, R14
        AND.W   #0xff3f, R15
        BIS.W   R14, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  113      Counter_Value >>= 1;          
        RRUM.W  #0x1, R11
        RRC.W   R10
//  114      
//  115      if((TIMERX[timer]->ID == 3u) && (Counter_Value > 65536))   //这个时候意味得选择更低频率的时钟了
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        AND.B   #0xc0, R14
        CMP.B   #0xc0, R14
        JNE     ??TIMER_PWM_SetFrequency_0
        CMP.W   #0x1, R11
        JNC     ??TIMER_PWM_SetFrequency_0
        JNE     ??TIMER_PWM_SetFrequency_5
        CMP.W   #0x1, R10
        JNC     ??TIMER_PWM_SetFrequency_0
//  116      {
//  117        if(TIMERX[timer]->SSEL == TIMER_SSEL_ACLK)   //如果时钟已经是最低的ACLK了，那么意味着设置的频率太低了，失败返回ERROR
??TIMER_PWM_SetFrequency_5:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        SWPB    R14
        AND.W   #0xff, R14
        AND.W   #0x3, R14
        CMP.B   #0x1, R14
        JNE     ??TIMER_PWM_SetFrequency_6
//  118        {
//  119          return ERROR;
        MOV.B   #0x0, R12
        JMP     ??TIMER_PWM_SetFrequency_2
//  120        }
//  121        //更换为更低的ACLK，从新配置
//  122        TIMERX[timer]->SSEL = TIMER_SSEL_ACLK;
??TIMER_PWM_SetFrequency_6:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x100, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  123        TIMERX[timer]->ID = 0u;  
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  124        Counter_Value = g_sClock.ACLK.nHZ/fre; 
        MOVX.W  &g_sClock + 24, R12
        MOVX.W  &g_sClock + 26, R13
        MOV.W   R6, R14
        MOV.W   R7, R15
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        MOV.W   R12, R10
        MOV.W   R13, R11
//  125        continue;  
        JMP     ??TIMER_PWM_SetFrequency_0
//  126      } 
//  127   }
//  128   if(Counter_Value <= 1)//出现这种情况,说明频率不合适
??TIMER_PWM_SetFrequency_3:
        CMP.W   #0x0, R11
        JNC     ??TIMER_PWM_SetFrequency_7
        JNE     ??TIMER_PWM_SetFrequency_8
        CMP.W   #0x2, R10
        JC      ??TIMER_PWM_SetFrequency_8
//  129   {
//  130     return ERROR; 
??TIMER_PWM_SetFrequency_7:
        MOV.B   #0x0, R12
        JMP     ??TIMER_PWM_SetFrequency_2
//  131   }
//  132 
//  133   TIMERX[timer]->CCR[0] = (uint16_t)(Counter_Value - 1u);//为什么要减一？？因为TAR/TBR计数器从CCR0变化到0还有一个计数周期
??TIMER_PWM_SetFrequency_8:
        MOV.W   R10, R15
        ADD.W   #0xffff, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0x12(R14)
//  134   TIMERX[timer]->IE = RESET;                      //关闭中断
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  135   TIMERX[timer]->MC = TIMER_MC_UP;                //增计数模式
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x10, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  136   
//  137   return SUCCESS;
        MOV.B   #0x1, R12
??TIMER_PWM_SetFrequency_2:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  138 }
//  139 /*******************************************************************************
//  140 *  函数名称：TIMER_PWM_SetChannelDuty(TIMERn timer,TIMER_CHn ch,uint32_t duty)
//  141 *  功能说明：PWM输出占空比设置
//  142 *  参数说明：TIMERn timer       ：定时器模块
//  143              TIMER_CHn ch       ：定时器通道
//  144              uint32_t duty      ：占空比
//  145 *  函数返回：无
//  146 *  使用例程：TIMER_PWM_SetChannelDuty(TIMER_A0,TIMER_CH1,800);  //修改定时器A0的TIMER_CH1通道占空比为(800/TIMAR_A0_PRECISON)*100%
//  147 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  148 void  TIMER_PWM_SetChannelDuty(TIMERn timer,TIMER_CHn ch,uint32_t duty)
TIMER_PWM_SetChannelDuty:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function TIMER_PWM_SetChannelDuty
//  149 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.W   R14, R8
        MOV.W   R15, R9
//  150   ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  151        ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  152        ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  153        ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  154        "TIMER_PWM_SetChannelDuty",
//  155        "定时器通道参数超出范围！"); //断言检测输入参数
        CMP.B   #0x0, R10
        JNE     ??TIMER_PWM_SetChannelDuty_0
        CMP.B   #0x5, R11
        JNC     ??TIMER_PWM_SetChannelDuty_1
??TIMER_PWM_SetChannelDuty_0:
        CMP.B   #0x1, R10
        JNE     ??TIMER_PWM_SetChannelDuty_2
        CMP.B   #0x3, R11
        JNC     ??TIMER_PWM_SetChannelDuty_1
??TIMER_PWM_SetChannelDuty_2:
        CMP.B   #0x2, R10
        JNE     ??TIMER_PWM_SetChannelDuty_3
        CMP.B   #0x3, R11
        JNC     ??TIMER_PWM_SetChannelDuty_1
??TIMER_PWM_SetChannelDuty_3:
        CMP.B   #0x3, R10
        JNE     ??TIMER_PWM_SetChannelDuty_4
        CMP.B   #0x7, R11
        JNC     ??TIMER_PWM_SetChannelDuty_1
??TIMER_PWM_SetChannelDuty_4:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_PWM_SetChannelDuty">`, R14
        MOV.W   #0x9b, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  156   
//  157   ASSERT(duty <= TIMER_PRECISON[timer],
//  158          "TIMER_PWM_SetChannelDuty",
//  159          "定时器占空比参数超出范围！");      //用断言检测 占空比是否合理
??TIMER_PWM_SetChannelDuty_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        CMPX.W  R9, TIMER_PRECISON + 2(R15)
        JNC     ??TIMER_PWM_SetChannelDuty_5
        JNE     ??TIMER_PWM_SetChannelDuty_6
        CMPX.W  R8, TIMER_PRECISON(R15)
        JC      ??TIMER_PWM_SetChannelDuty_6
??TIMER_PWM_SetChannelDuty_5:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\325\\274\\2`, R15
        MOVA    #`?<Constant "TIMER_PWM_SetChannelDuty">`, R14
        MOV.W   #0x9f, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  160   
//  161   TIMERX[timer]->CCR[ch] = (uint16_t)((duty * (TIMERX[timer]->CCR[0]+1))/TIMER_PRECISON[timer]);
??TIMER_PWM_SetChannelDuty_6:
        MOV.W   R8, R12
        MOV.W   R9, R13
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   0x12(R15), R14
        ADD.W   #0x1, R14
        MOV.W   #0x0, R15
          CFI FunCall ?Mul32
        CALLA   #?Mul32
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.W  TIMER_PRECISON(R15), R14
        MOVX.W  TIMER_PRECISON + 2(R15), R15
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        MOV.W   R12, 0x12(R15)
//  162 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  163 /*******************************************************************************
//  164 *  函数名称：TIMER_Interval_Us(TIMERn timer,uint32_t us)
//  165 *  功能说明：定时器定时初始化(单位：us)
//  166 *  参数说明：TIMERn timer       ：定时器模块
//  167              uint32_t us          : 定时时间
//  168 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  169 *  使用例程：TIMER_Interval_Us(TIMER_B0,2500);  //TB定时间隔2.5ms中断
//  170 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  171 STATUS  TIMER_Interval_Us(TIMERn timer,uint32_t us)
TIMER_Interval_Us:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function TIMER_Interval_Us
//  172 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R8
        MOV.W   R14, R6
        MOV.W   R15, R7
//  173 #ifdef DELAY_TIMER
//  174   ASSERT((timer != DELAY_TIMER),
//  175          "TIMER_Interval_Us",
//  176          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  177 #endif
//  178   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  179   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R8, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.W   R15, 0(R11)
//  180   TIMERX[timer]->ID = 0u;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  181   //计数值
//  182   uint32_t Counter_Value = (uint32_t)(us * g_sClock.SMCLK.fMHZ);
        MOV.W   R6, R12
        MOV.W   R7, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 20, R14
        MOVX.W  &g_sClock + 22, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        MOV.W   R12, R10
        MOV.W   R13, R11
//  183   while(Counter_Value > 65536)
??TIMER_Interval_Us_0:
        CMP.W   #0x1, R11
        JNC     ??TIMER_Interval_Us_1
        JNE     ??TIMER_Interval_Us_2
        CMP.W   #0x1, R10
        JNC     ??TIMER_Interval_Us_1
//  184   {
//  185      TIMERX[timer]->ID ++; 
??TIMER_Interval_Us_2:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        PUSH.W  R14
          CFI CFA SP+30
        MOV.B   R15, 0(SP)
        POP.W   R14
          CFI CFA SP+28
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        ADD.W   #0x1, R14
        RPT     #0x6
        RLAX.W  R14
        AND.W   #0xc0, R14
        AND.W   #0xff3f, R15
        BIS.W   R14, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  186      Counter_Value >>= 1;  
        RRUM.W  #0x1, R11
        RRC.W   R10
//  187      if((TIMERX[timer]->ID == 3u) && (Counter_Value > 65536))   //这个时候意味得选择更低频率的时钟了
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        AND.B   #0xc0, R14
        CMP.B   #0xc0, R14
        JNE     ??TIMER_Interval_Us_0
        CMP.W   #0x1, R11
        JNC     ??TIMER_Interval_Us_0
        JNE     ??TIMER_Interval_Us_3
        CMP.W   #0x1, R10
        JNC     ??TIMER_Interval_Us_0
//  188      {
//  189       if(TIMERX[timer]->SSEL == TIMER_SSEL_ACLK) //如果时钟已经是最低的ACLK了，那么意味着设置的频率太低了，失败返回ERROR
??TIMER_Interval_Us_3:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        SWPB    R14
        AND.W   #0xff, R14
        AND.W   #0x3, R14
        CMP.B   #0x1, R14
        JNE     ??TIMER_Interval_Us_4
//  190       {
//  191         return ERROR;
        MOV.B   #0x0, R12
        JMP     ??TIMER_Interval_Us_5
//  192       }
//  193       //更换为更低的ACLK，从新配置
//  194       TIMERX[timer]->SSEL = TIMER_SSEL_ACLK;
??TIMER_Interval_Us_4:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x100, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  195       TIMERX[timer]->ID = 0u;  
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  196       Counter_Value = (uint32_t)(us * g_sClock.ACLK.fMHZ);
        MOV.W   R6, R12
        MOV.W   R7, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 32, R14
        MOVX.W  &g_sClock + 34, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        MOV.W   R12, R10
        MOV.W   R13, R11
//  197       continue;  
        JMP     ??TIMER_Interval_Us_0
//  198      } 
//  199   }
//  200   if(Counter_Value <= 1)//出现这种情况,说明频率不合适
??TIMER_Interval_Us_1:
        CMP.W   #0x0, R11
        JNC     ??TIMER_Interval_Us_6
        JNE     ??TIMER_Interval_Us_7
        CMP.W   #0x2, R10
        JC      ??TIMER_Interval_Us_7
//  201   {
//  202     return ERROR; 
??TIMER_Interval_Us_6:
        MOV.B   #0x0, R12
        JMP     ??TIMER_Interval_Us_5
//  203   }
//  204   
//  205   TIMERX[timer]->CCR[0] = (uint16_t)(Counter_Value - 1u);//为什么要减一？？因为TAR/TBR计数器从CCR0变化到0还有一个计数周期
??TIMER_Interval_Us_7:
        MOV.W   R10, R15
        ADD.W   #0xffff, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0x12(R14)
//  206   TIMERX[timer]->CCTL[0].CAPMODE = RESET;          //比较模式
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x100, 0x2(R15)
//  207   TIMERX[timer]->IE = RESET;             //关闭溢出中断
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  208   TIMERX[timer]->CCTL[0].IE = RESET;     //关闭通道中断
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x10, 0x2(R15)
//  209   TIMERX[timer]->MC = TIMER_MC_UP;      //增计数模式
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x10, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  210   
//  211   return SUCCESS;
        MOV.B   #0x1, R12
??TIMER_Interval_Us_5:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  212 }
//  213 /*******************************************************************************
//  214 *  函数名称：TIMER_Delay_Us(TIMERn timer,uint32_t us)
//  215 *  功能说明：定时器延时（单位：ms）
//  216 *  参数说明：TIMERn timer       ：定时器模块
//  217              uint32_t us          : 定时时间
//  218 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  219 *  使用例程：TIMER_Delay_Us(TIMER_B0 ,5000);      //在此处延时5ms
//  220 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  221 STATUS TIMER_Delay_Us(TIMERn timer,uint32_t us)
TIMER_Delay_Us:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function TIMER_Delay_Us
//  222 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R8
        MOV.W   R14, R6
        MOV.W   R15, R7
//  223   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  224   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R8, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.W   R15, 0(R11)
//  225   TIMERX[timer]->ID = 0u;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  226   //计数值
//  227   uint32_t Counter_Value = (uint32_t)(us * g_sClock.SMCLK.fMHZ);
        MOV.W   R6, R12
        MOV.W   R7, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 20, R14
        MOVX.W  &g_sClock + 22, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        MOV.W   R12, R10
        MOV.W   R13, R11
//  228   while(Counter_Value > 65536)
??TIMER_Delay_Us_0:
        CMP.W   #0x1, R11
        JNC     ??TIMER_Delay_Us_2
        JNE     ??TIMER_Delay_Us_3
        CMP.W   #0x1, R10
        JNC     ??TIMER_Delay_Us_2
//  229   {
//  230      TIMERX[timer]->ID ++; 
??TIMER_Delay_Us_3:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        PUSH.W  R14
          CFI CFA SP+30
        MOV.B   R15, 0(SP)
        POP.W   R14
          CFI CFA SP+28
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        ADD.W   #0x1, R14
        RPT     #0x6
        RLAX.W  R14
        AND.W   #0xc0, R14
        AND.W   #0xff3f, R15
        BIS.W   R14, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  231      Counter_Value >>= 1;  
        RRUM.W  #0x1, R11
        RRC.W   R10
//  232      if((TIMERX[timer]->ID == 3u) && (Counter_Value > 65536))   //这个时候意味得选择更低频率的时钟了
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        AND.B   #0xc0, R14
        CMP.B   #0xc0, R14
        JNE     ??TIMER_Delay_Us_0
        CMP.W   #0x1, R11
        JNC     ??TIMER_Delay_Us_0
        JNE     ??TIMER_Delay_Us_4
        CMP.W   #0x1, R10
        JNC     ??TIMER_Delay_Us_0
//  233      {
//  234       if(TIMERX[timer]->SSEL == TIMER_SSEL_ACLK) //如果时钟已经是最低的ACLK了，那么意味着设置的频率太低了，失败返回ERROR
??TIMER_Delay_Us_4:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        SWPB    R14
        AND.W   #0xff, R14
        AND.W   #0x3, R14
        CMP.B   #0x1, R14
        JNE     ??TIMER_Delay_Us_5
//  235       {
//  236         return ERROR;
        MOV.B   #0x0, R12
        JMP     ??TIMER_Delay_Us_6
//  237       }
//  238       //更换为更低的ACLK，从新配置
//  239       TIMERX[timer]->SSEL = TIMER_SSEL_ACLK;
??TIMER_Delay_Us_5:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x100, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  240       TIMERX[timer]->ID = 0u;  
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  241       Counter_Value = (uint32_t)(us * g_sClock.ACLK.fMHZ);
        MOV.W   R6, R12
        MOV.W   R7, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 32, R14
        MOVX.W  &g_sClock + 34, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        MOV.W   R12, R10
        MOV.W   R13, R11
//  242       continue;  
        JMP     ??TIMER_Delay_Us_0
//  243      } 
//  244   }
//  245   if(Counter_Value <= 1)//出现这种情况,说明频率不合适
??TIMER_Delay_Us_2:
        CMP.W   #0x0, R11
        JNC     ??TIMER_Delay_Us_7
        JNE     ??TIMER_Delay_Us_8
        CMP.W   #0x2, R10
        JC      ??TIMER_Delay_Us_8
//  246   {
//  247     return ERROR; 
??TIMER_Delay_Us_7:
        MOV.B   #0x0, R12
        JMP     ??TIMER_Delay_Us_6
//  248   }
//  249   
//  250   TIMERX[timer]->CCR[0] = (uint16_t)(Counter_Value - 1u);//为什么要减一？？因为TAR/TBR计数器从CCR0变化到0还有一个计数周期
??TIMER_Delay_Us_8:
        MOV.W   R10, R15
        ADD.W   #0xffff, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0x12(R14)
//  251   TIMERX[timer]->CCTL[0].CAPMODE = RESET;          //比较模式
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x100, 0x2(R15)
//  252   TIMERX[timer]->IE = RESET;             //关闭溢出中断
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  253   TIMERX[timer]->CCTL[0].IE = RESET;     //关闭通道中断
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x10, 0x2(R15)
//  254   TIMERX[timer]->MC = TIMER_MC_UP;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x10, R15
        MOV.B   R8, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  255   
//  256   TIMERX[timer]->CCTL[0].CTL = 0;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0x2(R15)
//  257   TIMERX[timer]->IFG = RESET;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x1, 0(R15)
//  258   while(TIMERX[timer]->IFG == RESET);
??TIMER_Delay_Us_1:
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIT.W   #0x1, 0(R15)
        JNC     ??TIMER_Delay_Us_1
//  259   TIMERX[timer]->CTL = 0;
        MOV.B   R8, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0(R15)
//  260   
//  261   return SUCCESS;
        MOV.B   #0x1, R12
??TIMER_Delay_Us_6:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
//  262 }
//  263 /*******************************************************************************
//  264 *  函数名称：TIMER_Pluse_Init    (TIMERn timer)
//  265 *  功能说明：定时器脉冲计数初始化
//  266 *  参数说明：TIMERn timer       ：定时器模块
//  267 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  268 *  使用例程：TIMER_Pluse_Init    (TIMER_A1);    //定时器TA1初始化为脉冲计数功能
//  269 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  270 STATUS  TIMER_Pluse_Init    (TIMERn timer)
TIMER_Pluse_Init:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function TIMER_Pluse_Init
//  271 { 
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
//  272 #ifdef DELAY_TIMER
//  273   ASSERT((timer != DELAY_TIMER),
//  274          "TIMER_Pluse_Init",
//  275          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  276 #endif 
//  277   //端口设置为输入方向//选择第二功能
//  278   GPIO_Init(TIMER_CLK_PIN[timer].Port,TIMER_CLK_PIN[timer].Pin,GPI|SEL);
        MOV.W   #0x101, R14
        MOV.W   #0x1, R13
        MOV.B   R10, R15
        ADDA    R15, R15
        MOVX.B  TIMER_CLK_PIN + 1(R15), R15
        SUB.B   #0x1, R15
        JN      ??TIMER_Pluse_Init_0
        RPT     R15
        RLAX.W  R13
??TIMER_Pluse_Init_0:
        ADD.B   #0x1, R15
        MOV.B   R10, R15
        ADDA    R15, R15
        MOVX.B  TIMER_CLK_PIN(R15), R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//  279   
//  280   TIMERX[timer]->CLR = BIT_SET;                       
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  281   TIMERX[timer]->SSEL = TIMER_SSEL_INCLK;             //时钟源选择为外部输入
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x300, 0(R15)
//  282   TIMERX[timer]->ID = 0u;                             //不分频
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  283   TIMERX[timer]->MC = TIMER_MC_CONTINOUS;             //连续计数模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  284   TIMERX[timer]->IE = RESET;                          //禁止溢出中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  285   
//  286   return SUCCESS;
        MOV.B   #0x1, R12
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  287 }
//  288 /*******************************************************************************
//  289 *  函数名称：TIMER_Pluse_GetValue(TIMERn timer,uint16_t overflowTime)
//  290 *  功能说明：定时器脉冲计数值获取
//  291 *  参数说明：TIMERn timer       ：定时器模块
//  292              uint16_t overflowTime ：计数器溢出次数
//  293 *  函数返回：定时器脉冲计数值
//  294 *  使用例程：
//  295              int32 pulse = TIMER_Pluse_GetValue(TIMER_A1,0);    //在没有发生溢出的情况下读取脉冲个数
//  296              TIMER_Pluse_Clear   (TIMER_A1);                    //读取后应该要清零
//  297 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  298 uint32_t TIMER_Pluse_GetValue(TIMERn timer,uint16_t overflowTime)
TIMER_Pluse_GetValue:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function TIMER_Pluse_GetValue
          CFI NoCalls
//  299 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  300   return (TIMERX[timer]->R + (overflowTime*65536u));
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R14
        MOV.W   #0x0, R15
        MOV.W   R13, R10
        MOV.W   #0x0, R11
        MOV.W   R10, R11
        MOV.W   #0x0, R10
        ADD.W   R10, R14
        ADDC.W  R11, R15
        MOV.W   R14, R12
        MOV.W   R15, R13
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7
//  301 }
//  302 /*******************************************************************************
//  303 *  函数名称：TIMER_Pluse_Clear   (TIMERn timer)
//  304 *  功能说明：定时器脉冲计数值清零
//  305 *  参数说明：TIMERn timer       ：定时器模块
//  306 *  函数返回：无
//  307 *  使用例程：
//  308              int32 pulse = TIMER_Pluse_Read    (TIMER_A1,0);    //在没有发生溢出的情况下读取脉冲个数
//  309              TIMER_Pluse_Clear   (TIMER_A1);                    //读取后应该要清零
//  310 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  311 void   TIMER_Pluse_Clear   (TIMERn timer)
TIMER_Pluse_Clear:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function TIMER_Pluse_Clear
          CFI NoCalls
//  312 {
//  313   TIMERX[timer]->R = 0;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0x10(R15)
//  314 }
        RETA
          CFI EndBlock cfiBlock8
//  315 /*******************************************************************************
//  316 *  函数名称：TIMER_Capture_Init(TIMERn timer,TIMER_CHn ch,TIMER_CAPTUREn capmode)
//  317 *  功能说明：定时器捕获初始化
//  318 *  参数说明：TIMERn timer        ：定时器模块
//  319              TIMER_CHn ch        ：定时器通道
//  320              TIMER_CAPTUREn capmode：捕获模式
//  321 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  322 *  使用例程：TIMER_Capture_Init(TIMER_A0,TIMER_CH1,CAP_Rising);         //定时器TA0 CCR1通道初始化为边缘捕获，上升沿捕获
//  323 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  324 STATUS TIMER_Capture_Init(TIMERn timer,TIMER_CHn ch,TIMER_CAPTUREn capmode)
TIMER_Capture_Init:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function TIMER_Capture_Init
//  325 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.B   R14, R8
//  326 #ifdef DELAY_TIMER
//  327   ASSERT((timer != DELAY_TIMER),
//  328          "TIMER_Capture_Init",
//  329          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  330 #endif
//  331   ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  332        ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  333        ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  334        ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  335        "TIMER_Capture_Init",
//  336        "定时器通道参数超出范围！"); //断言检测输入参数
        CMP.B   #0x0, R10
        JNE     ??TIMER_Capture_Init_0
        CMP.B   #0x5, R11
        JNC     ??TIMER_Capture_Init_1
??TIMER_Capture_Init_0:
        CMP.B   #0x1, R10
        JNE     ??TIMER_Capture_Init_2
        CMP.B   #0x3, R11
        JNC     ??TIMER_Capture_Init_1
??TIMER_Capture_Init_2:
        CMP.B   #0x2, R10
        JNE     ??TIMER_Capture_Init_3
        CMP.B   #0x3, R11
        JNC     ??TIMER_Capture_Init_1
??TIMER_Capture_Init_3:
        CMP.B   #0x3, R10
        JNE     ??TIMER_Capture_Init_4
        CMP.B   #0x7, R11
        JNC     ??TIMER_Capture_Init_1
??TIMER_Capture_Init_4:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_Capture_Init">`, R14
        MOV.W   #0x150, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  337  
//  338   TIMERX[timer]->CCTL[ch].CAPMODE = BIT_SET;                //设为捕获模式
??TIMER_Capture_Init_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        BIS.W   #0x100, 0x2(R15)
//  339   TIMERX[timer]->CCTL[ch].CM = capmode;                 //选择捕获沿
        MOV.B   R8, R15
        RPT     #0x6
        RLAX.B  R15
        AND.W   #0xff, R15
        SWPB    R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.B   R11, R13
        ADDA    R13, R13
        MOVA    R13, R12
        ADDA    R12, R14
        MOV.W   0x2(R14), R14
        AND.W   #0x3fff, R14
        BIS.W   R15, R14
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R13
        ADDA    R13, R13
        MOVA    R13, R12
        ADDA    R12, R15
        MOV.W   R14, 0x2(R15)
//  340   
//  341   TIMERX[timer]->CCTL[ch].CCIS = (timer == TIMER_B0) ? TIMER_CCIS_1 : TIMER_CCIS_0;
        CMP.B   #0x3, R10
        JNE     ??TIMER_Capture_Init_5
        MOV.W   #0x1, R15
        JMP     ??TIMER_Capture_Init_6
??TIMER_Capture_Init_5:
        MOV.W   #0x0, R15
??TIMER_Capture_Init_6:
        RPT     #0x4
        RLAX.B  R15
        AND.W   #0xff, R15
        SWPB    R15
        AND.W   #0x3000, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.B   R11, R13
        ADDA    R13, R13
        MOVA    R13, R12
        ADDA    R12, R14
        MOV.W   0x2(R14), R14
        AND.W   #0xcfff, R14
        BIS.W   R15, R14
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R13
        ADDA    R13, R13
        MOVA    R13, R12
        ADDA    R12, R15
        MOV.W   R14, 0x2(R15)
//  342   
//  343   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  344   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  345   TIMERX[timer]->ID = 0u; //这里选择子系统时钟，除非频率特别低时才使用辅助时钟
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  346   TIMERX[timer]->IE = RESET;              //关闭溢出中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  347   TIMERX[timer]->CCTL[ch].IE = RESET;     //关闭通道中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        BIC.W   #0x10, 0x2(R15)
//  348   TIMERX[timer]->MC = TIMER_MC_CONTINOUS;             //连续计数模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  349   
//  350   //端口设置为输入方,选择第二功能
//  351   GPIO_Init(TIMER_CHANEL_PIN[timer][ch].Port,TIMER_CHANEL_PIN[timer][ch].Pin,GPI|SEL);
        MOV.W   #0x101, R14
        MOV.W   #0x1, R13
        MOV.B   R11, R15
        ADDA    R15, R15
        MOV.B   R10, R12
        ADDA    R12, R12
        MOVA    R12, R9
        ADDA    R12, R12
        ADDA    R12, R9
        ADDA    R12, R12
        ADDA    R9, R12
        MOVA    R12, R9
        ADDA    R9, R15
        MOVX.B  TIMER_CHANEL_PIN + 1(R15), R15
        SUB.B   #0x1, R15
        JN      ??TIMER_Capture_Init_7
        RPT     R15
        RLAX.W  R13
??TIMER_Capture_Init_7:
        ADD.B   #0x1, R15
        MOV.B   R10, R15
        ADDA    R15, R15
        MOVA    R15, R9
        ADDA    R15, R15
        ADDA    R15, R9
        ADDA    R15, R15
        ADDA    R9, R15
        MOV.B   R11, R9
        ADDA    R9, R9
        MOVA    R9, R12
        ADDA    R12, R15
        MOVX.B  TIMER_CHANEL_PIN(R15), R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//  352   
//  353   return SUCCESS;
        MOV.B   #0x1, R12
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
//  354 }
//  355 /*******************************************************************************
//  356 *  函数名称：TIMER_Capture_SetMode(TIMERn timer, TIMER_CHn ch, TIMER_CAPTUREn cap_mode)
//  357 *  功能说明：定时器捕获边沿设置
//  358 *  参数说明：TIMERn timer        ：定时器模块
//  359              TIMER_CHn ch        ：定时器通道
//  360              TIMER_CAPTUREn capmode：捕获模式
//  361 *  函数返回：无
//  362 *  使用例程：TIMER_Capture_SetMode(TIMER_A0,TIMER_CH1,CAP_Rising);         //定时器TA0 CCR1通道初始化为边缘捕获，上升沿捕获
//  363 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  364 void   TIMER_Capture_SetMode   (TIMERn timer, TIMER_CHn ch, TIMER_CAPTUREn cap_mode)
TIMER_Capture_SetMode:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function TIMER_Capture_SetMode
          CFI NoCalls
//  365 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
//  366    TIMERX[timer]->CCTL[ch].CM = cap_mode;                 //设置捕获沿
        MOV.B   R14, R15
        RPT     #0x6
        RLAX.B  R15
        AND.W   #0xff, R15
        SWPB    R15
        MOV.B   R12, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R11
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R8
        ADDA    R8, R11
        MOV.W   0x2(R11), R11
        AND.W   #0x3fff, R11
        BIS.W   R15, R11
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R8
        ADDA    R8, R15
        MOV.W   R11, 0x2(R15)
//  367 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  368 /*******************************************************************************
//  369 *  函数名称：TIMER_Capture_Clear     (TIMERn timer,TIMER_CHn ch)
//  370 *  功能说明：某一通道读取数据清零
//  371 *  参数说明：TIMERn timer       ：定时器模块
//  372              TIMER_CHn ch       ：定时器通道
//  373 *  函数返回：
//  374 *  使用例程：int16 overflowTime;  //定义变量，在定时器溢出中断里对该值增一
//  375              ......
//  376              data=TIMER_Capture_GetTime_Us(TIMER_A0,TIMER_CH1,overflowTime)
//  377              TIMER_Capture_Clear(TIMER_A0,TIMER_CH1);  //清零
//  378              overflowTime=0;       //清零
//  379 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  380 void   TIMER_Capture_Clear     (TIMERn timer,TIMER_CHn ch)
TIMER_Capture_Clear:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function TIMER_Capture_Clear
//  381 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.B   R13, R11
//  382   ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  383        ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  384        ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  385        ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  386        "TIMER_Capture_Clear",
//  387        "定时器通道参数超出范围！"); //断言检测输入参数
        CMP.B   #0x0, R10
        JNE     ??TIMER_Capture_Clear_0
        CMP.B   #0x5, R11
        JNC     ??TIMER_Capture_Clear_1
??TIMER_Capture_Clear_0:
        CMP.B   #0x1, R10
        JNE     ??TIMER_Capture_Clear_2
        CMP.B   #0x3, R11
        JNC     ??TIMER_Capture_Clear_1
??TIMER_Capture_Clear_2:
        CMP.B   #0x2, R10
        JNE     ??TIMER_Capture_Clear_3
        CMP.B   #0x3, R11
        JNC     ??TIMER_Capture_Clear_1
??TIMER_Capture_Clear_3:
        CMP.B   #0x3, R10
        JNE     ??TIMER_Capture_Clear_4
        CMP.B   #0x7, R11
        JNC     ??TIMER_Capture_Clear_1
??TIMER_Capture_Clear_4:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_Capture_Clear">`, R14
        MOV.W   #0x183, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  388   
//  389   TIMERX[timer]->CCR[ch] = 0u;
??TIMER_Capture_Clear_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        MOV.W   #0x0, 0x12(R15)
//  390   TIMERX[timer]->R = 0u;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0x10(R15)
//  391 }
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
//  392 /*******************************************************************************
//  393 *  函数名称：TIMER_Capture_GetValue(TIMERn timer,TIMER_CHn ch)
//  394 *  功能说明：读取发生捕获时定时器该通道计数值
//  395 *  参数说明：TIMERn timer       ：定时器模块
//  396              TIMER_CHn ch       ：定时器通道
//  397 *  函数返回：
//  398 *  使用例程：
//  399              uint16_t value = TIMER_Capture_GetValue(TIMER_A0,TIMER_CH1);  //读取发生捕获时的时间
//  400 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  401 uint16_t TIMER_Capture_GetValue(TIMERn timer,TIMER_CHn ch)
TIMER_Capture_GetValue:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function TIMER_Capture_GetValue
//  402 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.B   R13, R11
//  403   ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  404        ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  405        ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  406        ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  407        "TIMER_Capture_GetValue",
//  408        "定时器通道参数超出范围！"); //断言检测输入参数
        CMP.B   #0x0, R10
        JNE     ??TIMER_Capture_GetValue_0
        CMP.B   #0x5, R11
        JNC     ??TIMER_Capture_GetValue_1
??TIMER_Capture_GetValue_0:
        CMP.B   #0x1, R10
        JNE     ??TIMER_Capture_GetValue_2
        CMP.B   #0x3, R11
        JNC     ??TIMER_Capture_GetValue_1
??TIMER_Capture_GetValue_2:
        CMP.B   #0x2, R10
        JNE     ??TIMER_Capture_GetValue_3
        CMP.B   #0x3, R11
        JNC     ??TIMER_Capture_GetValue_1
??TIMER_Capture_GetValue_3:
        CMP.B   #0x3, R10
        JNE     ??TIMER_Capture_GetValue_4
        CMP.B   #0x7, R11
        JNC     ??TIMER_Capture_GetValue_1
??TIMER_Capture_GetValue_4:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_Capture_GetValue">`, R14
        MOV.W   #0x198, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  409   
//  410   return TIMERX[timer]->CCR[ch];
??TIMER_Capture_GetValue_1:
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R15
        MOV.B   R11, R11
        ADDA    R11, R11
        MOVA    R11, R14
        ADDA    R14, R15
        MOV.W   0x12(R15), R12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock12
//  411 }
//  412 /*******************************************************************************
//  413 *  函数名称：TIMER_Capture_CalTime_Us(uint16_t start_value,uint16_t stop_value,uint16_t overflowTime)
//  414 *  功能说明：读取发生捕获时定时器该通道计数值
//  415 *  参数说明：uint16_t start_value  ：捕获起始值
//  416              uint16_t stop_value   ：捕获结束值
//  417              uint16_t overflowTime ：计数器溢出次数
//  418 *  函数返回：
//  419 *  使用例程：uint16 overflowTime;  //定义变量，在定时器溢出中断里对该值增一
//  420              ......
//  421              TIMER_Capture_CalTime_Us(0,TIMER_Capture_GetValue  (TIMER_A0,TIMER_CH1),overflowTime);  //读取发生捕获时的时间
//  422              overflowTime=0;       //清零
//  423 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  424 uint32_t TIMER_Capture_CalTime_Us(uint16_t start_value,uint16_t stop_value,uint16_t overflowTime)
TIMER_Capture_CalTime_Us:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function TIMER_Capture_CalTime_Us
//  425 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R15
        MOV.W   R13, R12
//  426   return (uint32_t)((((int32_t)stop_value - (int32_t)start_value) + (uint32_t)overflowTime*65536)/g_sClock.SMCLK.fMHZ);
        MOV.W   #0x0, R13
        MOV.W   R15, R10
        MOV.W   #0x0, R11
        SUB.W   R10, R12
        SUBC.W  R11, R13
        MOV.W   #0x0, R15
        MOV.W   R14, R15
        MOV.W   #0x0, R14
        ADD.W   R14, R12
        ADDC.W  R15, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 20, R14
        MOVX.W  &g_sClock + 22, R15
          CFI FunCall _Div32f
        CALLA   #_Div32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock13
//  427 }
//  428 /*******************************************************************************
//  429 *  函数名称：TIMER_Timer_Init      (TIMERn timer)
//  430 *  功能说明：计时功能初始化
//  431 *  参数说明：TIMERn timer       ：定时器模块
//  432 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  433 *  使用例程：TIMER_Timer_Init      (TIMER_A1);     //定时器TA1初始化为计时器
//  434 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  435 STATUS   TIMER_Timer_Init      (TIMERn timer)
TIMER_Timer_Init:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function TIMER_Timer_Init
          CFI NoCalls
//  436 {
        MOV.B   R12, R14
//  437 #ifdef DELAY_TIMER
//  438  ASSERT((timer != DELAY_TIMER),
//  439          "TIMER_Timer_Init",
//  440          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  441 #endif
//  442   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R14, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  443   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;             //这里选择子系统时钟
        MOV.B   R14, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R14, R13
        RLAM.A  #0x2, R13
        MOVX.A  TIMERX(R13), R13
        MOV.W   R15, 0(R13)
//  444   TIMERX[timer]->ID = 0u; 
        MOV.B   R14, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  445   TIMERX[timer]->MC = TIMER_MC_STOP;                  //先停止计数计数
        MOV.B   R14, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xffcf, 0(R15)
//  446   TIMERX[timer]->IE = RESET;                          //禁止溢出中断
        MOV.B   R14, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  447   
//  448   return SUCCESS;
        MOV.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock14
//  449 }
//  450 /*******************************************************************************
//  451 *  函数名称：TIMER_Timer_Start(TIMERn timer)
//  452 *  功能说明：计时功能开始计时
//  453 *  参数说明：TIMERn timer       ：定时器模块
//  454 *  函数返回：无
//  455 *  使用例程：TIMER_Timer_Start(TIMER_A1);      //计时器开始计时
//  456 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  457 void   TIMER_Timer_Start(TIMERn timer)
TIMER_Timer_Start:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function TIMER_Timer_Start
          CFI NoCalls
//  458 {
//  459   TIMERX[timer]->R = 0u;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0x10(R15)
//  460   TIMERX[timer]->MC = TIMER_MC_CONTINUOUS;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  461 }
        RETA
          CFI EndBlock cfiBlock15
//  462 /*******************************************************************************
//  463 *  函数名称：TIMER_Timer_Stop (TIMERn timer)
//  464 *  功能说明：计时功能停止计时
//  465 *  参数说明：TIMERn timer       ：定时器模块
//  466 *  函数返回：返回当前计数值
//  467 *  使用例程：TIMER_Timer_Stop (TIMER_A1);   //计时器停止计时
//  468 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  469 uint16_t   TIMER_Timer_Stop (TIMERn timer)
TIMER_Timer_Stop:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function TIMER_Timer_Stop
          CFI NoCalls
//  470 {
//  471    TIMERX[timer]->MC = TIMER_MC_STOP;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xffcf, 0(R15)
//  472    return TIMERX[timer]->R;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R12
        RETA
          CFI EndBlock cfiBlock16
//  473 }
//  474 /*******************************************************************************
//  475 *  函数名称：TIMER_Timer_GetTime_Us(TIMERn timer,uint16_t overflowTime)
//  476 *  功能说明：计时时间读取
//  477 *  参数说明：TIMERn timer       ：定时器模块
//  478              uint16_t overflowTime ：计数器溢出次数
//  479 *  函数返回：返回计时时间 （单位：us）
//  480 *  使用例程：int16 overflowTime;  //定义变量，在定时器溢出中断里对该值增一
//  481              ......
//  482              TIMER_Timer_GetTime_Us(TIMAER_A1,overflowTime);  //读取计时时间
//  483              overflowTime=0;       //清零
//  484 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  485 uint32_t TIMER_Timer_GetTime_Us(TIMERn timer,uint16_t overflowTime)
TIMER_Timer_GetTime_Us:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function TIMER_Timer_GetTime_Us
//  486 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  487   return (uint32_t)((TIMERX[timer]->R + overflowTime*65536u)/g_sClock.SMCLK.fMHZ);
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R10
        MOV.W   #0x0, R11
        MOV.W   R13, R14
        MOV.W   #0x0, R15
        MOV.W   R14, R15
        MOV.W   #0x0, R14
        ADD.W   R14, R10
        ADDC.W  R15, R11
        MOV.W   R10, R12
        MOV.W   R11, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 20, R14
        MOVX.W  &g_sClock + 22, R15
          CFI FunCall _Div32f
        CALLA   #_Div32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock17
//  488 }
//  489 /*******************************************************************************
//  490 *  函数名称：TIMER_Run (TIMERn timer)
//  491 *  功能说明：定时器工作
//  492 *  参数说明：TIMERn timer       ：定时器模块
//  493 *  函数返回：无
//  494 *  使用例程：TIMER_Clear_Counter (TIMAER_A1)；  //启动定时器A1
//  495 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  496 void   TIMER_Run (TIMERn timer)
TIMER_Run:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function TIMER_Run
          CFI NoCalls
//  497 {
//  498   TIMERX[timer]->MC = TIMER_MC_CONTINUOUS;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  499 }
        RETA
          CFI EndBlock cfiBlock18
//  500 /*******************************************************************************
//  501 *  函数名称：TIMER_Stop (TIMERn timer)
//  502 *  功能说明：定时器工作
//  503 *  参数说明：TIMERn timer       ：定时器模块
//  504 *  函数返回：无
//  505 *  使用例程：TIMER_Stop(TIMAER_A1)；  //停止定时器A1
//  506 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  507 void   TIMER_Stop (TIMERn timer)
TIMER_Stop:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function TIMER_Stop
          CFI NoCalls
//  508 {
//  509   TIMERX[timer]->MC = TIMER_MC_STOP;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xffcf, 0(R15)
//  510 }
        RETA
          CFI EndBlock cfiBlock19
//  511 /*******************************************************************************
//  512 *  函数名称：TIMER_GetCounterValue (TIMERn timer)
//  513 *  功能说明：读取定时器计数值
//  514 *  参数说明：TIMERn timer  ：定时器模块
//  515 *  函数返回：uint16_t      ：计数值
//  516 *  使用例程：uint16_t value = TIMER_GetCounterValue(TIMAER_A1)；  //读取定时器A1计数值
//  517 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  518 uint16_t   TIMER_GetCounterValue (TIMERn timer)
TIMER_GetCounterValue:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function TIMER_GetCounterValue
          CFI NoCalls
//  519 {
//  520   return TIMERX[timer]->R;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R12
        RETA
          CFI EndBlock cfiBlock20
//  521 }
//  522 /*******************************************************************************
//  523 *  函数名称：TIMER_SetCounterValue(TIMERn timer,uint16_t value)
//  524 *  功能说明：设置定时器计数值
//  525 *  参数说明：TIMERn timer       ：定时器模块
//  526              uint16_t value     ：计数值
//  527 *  函数返回：无
//  528 *  使用例程：TIMER_SetCounterValue(TIMAER_A1,0)；  //设置定时器A1计数值为0
//  529 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  530 void   TIMER_SetCounterValue (TIMERn timer,uint16_t value)
TIMER_SetCounterValue:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function TIMER_SetCounterValue
          CFI NoCalls
//  531 {
//  532   TIMERX[timer]->R = value;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   R13, 0x10(R15)
//  533 }
        RETA
          CFI EndBlock cfiBlock21
//  534 /*******************************************************************************
//  535 *  函数名称：TIMER_GetChannelCounterValue (TIMERn timer,TIMER_CHn ch)
//  536 *  功能说明：读取定时器通道计数值
//  537 *  参数说明：TIMERn timer       ：定时器模块
//  538              TIMER_CHn ch       ：定时器通道             
//  539 *  函数返回：uint16_t value     ：该通道的计数值
//  540 *  使用例程：uint16_t value = TIMER_GetChannelCounterValue(TIMAER_A1,TIMER_CH4)；  //读取定时器A1通道4计数值
//  541 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  542 uint16_t   TIMER_GetChannelCounterValue (TIMERn timer,TIMER_CHn ch)
TIMER_GetChannelCounterValue:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function TIMER_GetChannelCounterValue
//  543 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.B   R13, R11
//  544   ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  545        ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  546        ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  547        ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  548        "TIMER_GetChannelCounterValue",
//  549        "定时器通道参数超出范围！"); //断言检测输入参数
        CMP.B   #0x0, R10
        JNE     ??TIMER_GetChannelCounterValue_0
        CMP.B   #0x5, R11
        JNC     ??TIMER_GetChannelCounterValue_1
??TIMER_GetChannelCounterValue_0:
        CMP.B   #0x1, R10
        JNE     ??TIMER_GetChannelCounterValue_2
        CMP.B   #0x3, R11
        JNC     ??TIMER_GetChannelCounterValue_1
??TIMER_GetChannelCounterValue_2:
        CMP.B   #0x2, R10
        JNE     ??TIMER_GetChannelCounterValue_3
        CMP.B   #0x3, R11
        JNC     ??TIMER_GetChannelCounterValue_1
??TIMER_GetChannelCounterValue_3:
        CMP.B   #0x3, R10
        JNE     ??TIMER_GetChannelCounterValue_4
        CMP.B   #0x7, R11
        JNC     ??TIMER_GetChannelCounterValue_1
??TIMER_GetChannelCounterValue_4:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_GetChannelCount...">`, R14
        MOV.W   #0x225, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  550   
//  551   return TIMERX[timer]->CCR[ch];
??TIMER_GetChannelCounterValue_1:
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R15
        MOV.B   R11, R11
        ADDA    R11, R11
        MOVA    R11, R14
        ADDA    R14, R15
        MOV.W   0x12(R15), R12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock22
//  552 }
//  553 /*******************************************************************************
//  554 *  函数名称：TIMER_SetChannelCounterValue(TIMERn timer,uint16_t value)
//  555 *  功能说明：设置定时器计数值
//  556 *  参数说明：TIMERn timer       ：定时器模块
//  557              TIMER_CHn ch       ：定时器通道
//  558              uint16_t value     ：计数值
//  559 *  函数返回：无
//  560 *  使用例程：TIMER_SetChannelCounterValue(TIMAER_A1,TIMER_CH4,0)；  //设置定时器A1通道4计数值为0
//  561 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  562 void   TIMER_SetChannelCounterValue (TIMERn timer,TIMER_CHn ch,uint16_t value)
TIMER_SetChannelCounterValue:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function TIMER_SetChannelCounterValue
//  563 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.W   R14, R8
//  564   ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  565        ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  566        ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  567        ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  568        "TIMER_SetChannelCounterValue",
//  569        "定时器通道参数超出范围！"); //断言检测输入参数
        CMP.B   #0x0, R10
        JNE     ??TIMER_SetChannelCounterValue_0
        CMP.B   #0x5, R11
        JNC     ??TIMER_SetChannelCounterValue_1
??TIMER_SetChannelCounterValue_0:
        CMP.B   #0x1, R10
        JNE     ??TIMER_SetChannelCounterValue_2
        CMP.B   #0x3, R11
        JNC     ??TIMER_SetChannelCounterValue_1
??TIMER_SetChannelCounterValue_2:
        CMP.B   #0x2, R10
        JNE     ??TIMER_SetChannelCounterValue_3
        CMP.B   #0x3, R11
        JNC     ??TIMER_SetChannelCounterValue_1
??TIMER_SetChannelCounterValue_3:
        CMP.B   #0x3, R10
        JNE     ??TIMER_SetChannelCounterValue_4
        CMP.B   #0x7, R11
        JNC     ??TIMER_SetChannelCounterValue_1
??TIMER_SetChannelCounterValue_4:
        MOVA    #`?<Constant "\\266\\250\\312\\261\\306\\367\\315\\250\\2`, R15
        MOVA    #`?<Constant "TIMER_SetChannelCount...">`, R14
        MOV.W   #0x239, R13
        MOVA    #`?<Constant "G:\\\\\\261\\310\\310\\374\\\\2020\\265\\347`, R12
          CFI FunCall assert_failed
        CALLA   #assert_failed
//  570   
//  571   TIMERX[timer]->CCR[ch] = value;
??TIMER_SetChannelCounterValue_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R11, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        MOV.W   R8, 0x12(R15)
//  572 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock23
//  573 /*******************************************************************************
//  574 *  函数名称：TIMER_GetChannelPinInValue(TIMERn timer, TIMER_CHn ch)
//  575 *  功能说明：获取通道输入值
//  576 *  参数说明：TIMERn timer       ：定时器模块
//  577              TIMER_CHn ch       ：定时器通道
//  578 *  函数返回：STATUS : BIT_SET-输入高电平 RESET-输入低电平
//  579 *  使用例程：STATUS status = TIMER_GetChannelInValue(TIMAER_A1, TIMER_CH1);  //读取定时器A1通道1输入电平
//  580 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  581 STATUS TIMER_GetChannelPinInValue (TIMERn timer, TIMER_CHn ch)
TIMER_GetChannelPinInValue:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function TIMER_GetChannelPinInValue
          CFI NoCalls
//  582 {
//  583   return (TIMERX[timer]->CCTL[ch].CH_CCI) ? BIT_SET : RESET;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x2(R15), R12
        RPT     #0x3
        RRUX.B  R12
        AND.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock24
//  584 }
//  585 /*******************************************************************************
//  586 *  函数名称：TIMER_GetChannelPinOutValue(TIMERn timer, TIMER_CHn ch)
//  587 *  功能说明：获取通道输出值
//  588 *  参数说明：TIMERn timer       ：定时器模块
//  589              TIMER_CHn ch       ：定时器通道
//  590 *  函数返回：STATUS : BIT_SET-输出高电平 RESET-输出低电平
//  591 *  使用例程：STATUS status = TIMER_GetChannelOutValue(TIMAER_A1, TIMER_CH1);  //读取定时器A1通道1输出电平
//  592 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  593 STATUS TIMER_GetChannelPinOutValue(TIMERn timer, TIMER_CHn ch)
TIMER_GetChannelPinOutValue:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function TIMER_GetChannelPinOutValue
          CFI NoCalls
//  594 {
//  595   return (TIMERX[timer]->CCTL[ch].CH_OUT) ? BIT_SET : RESET;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x2(R15), R12
        RPT     #0x2
        RRUX.B  R12
        AND.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock25
//  596 }
//  597 /*******************************************************************************
//  598 *  函数名称：TIMER_ITConfig (TIMERn timer,TIMER_IRQn irqn,STATUS ITState)
//  599 *  功能说明：设置是否使能TIMER的某一个中断
//  600 *  参数说明：TIMERn timer       ：定时器模块
//  601              TIMER_IRQn irqn    ：中断事件
//  602              STATUS ITState     ：是否使能中断
//  603 *  函数返回：无
//  604 *  使用例程：TIMER_ITConfig (TIMAER_A1,TIMER_CCR0_IRQn,ENABLE); //使能定时器1通道0中断，即定时中断
//  605 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  606 void  TIMER_ITConfig (TIMERn timer,TIMER_IRQn irqn,STATUS ITState)
TIMER_ITConfig:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function TIMER_ITConfig
          CFI NoCalls
//  607 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  608   if(irqn == TIMER_OverFlow_IRQn)
        CMP.B   #0x7, R13
        JNE     ??TIMER_ITConfig_2
//  609   {
//  610     TIMERX[timer]->IE = ITState;
        MOV.B   R14, R14
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIT.B   #0x1, R14
        JC      ??TIMER_ITConfig_3
        BIC.W   #0x2, 0(R15)
        JMP     ??TIMER_ITConfig_0
??TIMER_ITConfig_3:
        BIS.W   #0x2, 0(R15)
        JMP     ??TIMER_ITConfig_0
//  611   }
//  612   else
//  613   {
//  614     TIMERX[timer]->CCTL[irqn].IE = ITState;
??TIMER_ITConfig_2:
        MOV.B   R14, R14
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R11
        ADDA    R11, R15
        BIT.B   #0x1, R14
        JC      ??TIMER_ITConfig_4
        BIC.W   #0x10, 0x2(R15)
        JMP     ??TIMER_ITConfig_0
??TIMER_ITConfig_4:
        BIS.W   #0x10, 0x2(R15)
//  615   }
//  616 }
??TIMER_ITConfig_0:
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock26
//  617 /*******************************************************************************
//  618 *  函数名称：TIMER_GetITStatus(TIMERn timer,TIMER_IRQn irqn)
//  619 *  功能说明：获取TIMER的某一个中断标志
//  620 *  参数说明：TIMERn timer       ：定时器模块
//  621              TIMER_IRQn irqn    ：中断事件
//  622 *  函数返回：STATUS : TRUE-中断事件发生 FALSE-中断事件未发生
//  623 *  使用例程：if(TRUE == TIMER_GetITStatus(TIMAER_A1,TIMER_CCR1_IRQn)){...} //判断定时器A1通道1中断事件是否发生
//  624 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  625 STATUS TIMER_GetITStatus(TIMERn timer,TIMER_IRQn irqn)
TIMER_GetITStatus:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function TIMER_GetITStatus
          CFI NoCalls
//  626 {
//  627   if(irqn == TIMER_OverFlow_IRQn)
        CMP.B   #0x7, R13
        JNE     ??TIMER_GetITStatus_0
//  628   {
//  629     return ((TIMERX[timer]->IFG == BIT_SET) ? TRUE : FALSE);
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   @R15, R12
        AND.B   #0x1, R12
        RETA
//  630   }
//  631   else
//  632   {
//  633     return ((TIMERX[timer]->CCTL[irqn].IFG == BIT_SET) ? TRUE : FALSE);
??TIMER_GetITStatus_0:
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x2(R15), R12
        AND.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock27
//  634   }
//  635 }
//  636 /*******************************************************************************
//  637 *  函数名称：TIMER_ClearITPendingBit(TIMERn timer,TIMER_IRQn irqn)
//  638 *  功能说明：清除TIMER的某一个中断标志
//  639 *  参数说明：TIMERn timer       ：定时器模块
//  640              TIMER_IRQn irqn    ：中断事件
//  641 *  函数返回：无
//  642 *  使用例程：TIMER_ClearITPendingBit(TIMAER_A1,TIMER_CCR1_IRQn);   //清除定时器通道1中断标志位
//  643 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  644 void  TIMER_ClearITPendingBit(TIMERn timer,TIMER_IRQn irqn)
TIMER_ClearITPendingBit:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function TIMER_ClearITPendingBit
          CFI NoCalls
//  645 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
//  646   if(irqn == TIMER_OverFlow_IRQn)
        CMP.B   #0x7, R13
        JNE     ??TIMER_ClearITPendingBit_0
//  647   {
//  648     TIMERX[timer]->IFG = RESET;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x1, 0(R15)
        JMP     ??TIMER_ClearITPendingBit_1
//  649   }
//  650   else
//  651   {
//  652     TIMERX[timer]->CCTL[irqn].IFG = RESET;
??TIMER_ClearITPendingBit_0:
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R14
        ADDA    R14, R14
        MOVA    R14, R10
        ADDA    R10, R15
        BIC.W   #0x1, 0x2(R15)
//  653   }
//  654 }
??TIMER_ClearITPendingBit_1:
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock28

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 
// 3 642 bytes in segment CODE
//   400 bytes in segment DATA20_C
// 
// 3 642 bytes of CODE  memory
//   400 bytes of CONST memory
//
//Errors: none
//Warnings: none
