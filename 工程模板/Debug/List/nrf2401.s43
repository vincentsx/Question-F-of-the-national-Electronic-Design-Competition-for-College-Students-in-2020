///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V6.30.1.934/W32 for MSP430          12/Oct/2020  03:29:57
// Copyright 1996-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
//
//    __rt_version  =  3
//    __double_size =  32
//    __reg_r4      =  free
//    __reg_r5      =  free
//    __pic         =  no
//    __core        =  430X
//    __data_model  =  large
//    __code_model  =  large
//    Source file   =  
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nrf24l01\nrf2401.c
//    Command line  =  
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nrf24l01\nrf2401.c
//        -D DEBUG -D RAM_VECTOR -lA
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Debug\List\ -o
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Debug\Obj\ --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
//        -D__MSP430F5529__ -e --double=32 --dlib_config "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.2\430\lib\dlib\dl430xllff.h"
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\inc\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_config\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_User\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\srcUSB\USB_API\USB_CDC_API\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_API\USB_HID_API\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Drivers\src\USB\USB_API\USB_MSC_API\
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\delay\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\18b20\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\KEY\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\LED\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\12864\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\oled\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\mpu6050\inc\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\mpu6050\src\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nokia5110\inc\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nokia5110\src\
//        -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\LQ_1.8_TFT\
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\LCD_API\
//        -I G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\2.2TFT\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nrf24l01\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\System\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\System\inc\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\System\src\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\User\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\User\USER\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\UCOSII\CONFIG\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\uCOSII\App\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\uCOSII\CONFIHG\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\uCOSII\PORT\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\UCOSII\CORE\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\FatFs\ -I
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Lib\FatFs\option\ -I
//        G:\比赛\2020电赛\MSP430F5529库函数2.6\MSP430F5529库函数2.6\C版\工程模板\User\USER\
//        --core=430X --data_model=large -On --multiplier=32
//        --hw_workaround=CPU40 --code_model=large
//    List file     =  
//        G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\Debug\List\nrf2401.s43
//
///////////////////////////////////////////////////////////////////////////////

        NAME nrf2401

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__code_model", "large"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?CopyMemoryWords20
        EXTERN ?CopyMemoryBytes
        EXTERN ?cstart_init_zero20
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC NRF2401_IRQ_Handler
        PUBLIC NRF2401_Init
        PUBLIC NRF2401_RecData
        PUBLIC NRF2401_SendData
        PUBLIC NRF2401_SetRXMode
        PUBLIC NRF2401_SetTXMode
        PUBLIC RX_ADDRESS
        PUBLIC TX_ADDRESS
        PUBWEAK _A_PBOUT_L
        PUBWEAK _A_PDOUT_L
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN GPIO_MultiBits_Init
        EXTERN SPI_Master_Init
        EXTERN SPI_SendReadByte

// G:\比赛\2020电赛\代码\MSP430\测试功能\工程模板\HardWare\nrf24l01\nrf2401.c
//    1 #include "nrf2401.H"

        ASEGN DATA16_AN:DATA:NOROOT,0222H
// union <unnamed> __data16 _A_PBOUT_L
_A_PBOUT_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0262H
// union <unnamed> __data16 _A_PDOUT_L
_A_PDOUT_L:
        DS8 2
//    2 //********************************************************************************************************************// 
//    3 // SPI(nRF24L01) 指令
//    4 #define READ_REG    0x00   // 读配置寄存器
//    5 #define WRITE_REG   0x20   // 写配置寄存器
//    6 #define RD_RX_PLOAD 0x61   // 读取RX FIFO中的数据
//    7 #define WR_TX_PLOAD 0xA0   // 向TX FIFO中写入数据
//    8 #define FLUSH_TX    0xE1   // 清除TX FIFO中的数据 应用于发射模式下
//    9 #define FLUSH_RX    0xE2   // 清除RX FIFO中的数据 应用于接收模式下
//   10 #define REUSE_TX_PL 0xE3   // 重新使用上一包有效数据
//   11 #define NOP         0xFF   // 保留
//   12 //********************************************************************************************************************// 
//   13 // SPI(nRF24L01) 寄存器(地址)
//   14 #define CONFIG      0x00  //配置发送状态，CRC校验模式以及发收发状态响应方式
//   15 
//   16 #define MASK_RX_DR  BIT6  //可屏蔽中断-接收中断 1：屏蔽中断
//   17 #define MASK_TX_DS  BIT5  //可屏蔽中断-发送完成中断
//   18 #define MASK_MAX_RT BIT4  //可屏蔽中断-达到最大重发次数中断
//   19 #define EN_CRC      BIT3  //使能CRC
//   20 #define CRCO        BIT2  //0：CRC8位: 1：16位
//   21 #define PWR_UP      BIT1  //1：上电 0：掉电
//   22 #define PRIM_RX     BIT0  //1：接收模式 0：发射模式
//   23 
//   24 #define EN_AA       0x01  //自动应答功能设置
//   25 #define EN_RXADDR   0x02  //可用信道设置
//   26 #define SETUP_AW    0x03  //收发地址宽度设置
//   27 #define SETUP_RETR  0x04  //自动重发功能设设置
//   28 #define RF_CH       0x05  //工作频率设定
//   29 #define RF_SETUP    0x06  //
//   30 #define STATUS      0x07  //
//   31 #define OBSERVE_TX  0x08  //
//   32 #define CD          0x09  //
//   33 #define RX_ADDR_P0  0x0A
//   34 #define RX_ADDR_P1  0x0B
//   35 #define RX_ADDR_P2  0x0C
//   36 #define RX_ADDR_P3  0x0D
//   37 #define RX_ADDR_P4  0x0E
//   38 #define RX_ADDR_P5  0x0F
//   39 #define TX_ADDR     0x10
//   40 #define RX_PW_P0    0x11
//   41 #define RX_PW_P1    0x12
//   42 #define RX_PW_P2    0x13
//   43 #define RX_PW_P3    0x14
//   44 #define RX_PW_P4    0x15
//   45 #define RX_PW_P5    0x16
//   46 #define FIFO_STATUS 0x17
//   47 
//   48 //几个重要的状态标记
//   49 #define STATUS_TX_FULL     0x01        //TX FIFO 寄存器满标志。 1 为 满，0为 不满
//   50 #define STATUS_MAX_RT      0x10        //达到最大重发次数中断标志位
//   51 #define STATUS_TX_DS       0x20        //发送完成中断标志位
//   52 #define STATUS_RX_DR       0x40        //接收到数据中断标志位
//   53 

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
//   54 const uint8_t TX_ADDRESS[TX_ADR_WIDTH]={0xE1,0xE2,0xE3,0xE4,0xE5}; //发送地址
TX_ADDRESS:
        DC8 225, 226, 227, 228, 229

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
//   55 const uint8_t RX_ADDRESS[RX_ADR_WIDTH]={0xE1,0xE2,0xE3,0xE4,0xE5}; //接收地址
RX_ADDRESS:
        DC8 225, 226, 227, 228, 229
//   56 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   57 static s_NRF24L01 s_nrf24l01;
s_nrf24l01:
        DS8 24
//   58 /***********************************************************************************************
//   59  功能：NRF24L01 读写一个字节
//   60  形参：发送的数据
//   61  返回：读到的数据
//   62  详解：调用SPI模块
//   63 ************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   64 static uint8_t NRF2401_ReadWriteByte(uint8_t data)
NRF2401_ReadWriteByte:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function NRF2401_ReadWriteByte
//   65 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
//   66 #if NRF24L01HardWareSPI
//   67   return NRF2401HardWareSPI_SendByte(data);   //发送并读取一字节数据
        MOV.B   R10, R13
        MOV.B   #0x3, R12
          CFI FunCall SPI_SendReadByte
        CALLA   #SPI_SendReadByte
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//   68 #else
//   69   for(uint8_t i=0;i < 8;i++)          // 循环8次
//   70   {
//   71     NRF2401_SIMO = (data&0x80) ? 1 : 0;//上升沿发送数据// byte最高位输出到MOSI
//   72     data <<= 1;             // 低一位移位到最高位
//   73     NRF2401_SCL = 1; 
//   74     if(NRF2401_SOMI)            // 拉高SCK，nRF24L01从MOSI读入1位数据，同时从MISO输出1位数据
//   75       data |= 0x01;       	// 读MISO到byte最低位
//   76     NRF2401_SCL = 0;            	// SCK置低
//   77   }
//   78   return(data);           	// 返回读出的一字节
//   79 #endif
//   80 }
//   81 /***********************************************************************************************
//   82  功能：NRF24L01 写寄存器
//   83  形参：reg: 寄存器
//   84        value:写入的值
//   85  返回：读到的数据
//   86  详解：无
//   87 ************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   88 static uint8_t NRF2401_ReadWriteReg(uint8_t reg,uint8_t value)
NRF2401_ReadWriteReg:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function NRF2401_ReadWriteReg
//   89 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R11
        MOV.B   R13, R10
//   90 	NRF2401_CSN = 0;                   // CSN low, init SPI transaction
        BIC.B   #0x4, &0x263
//   91 	uint8_t status = NRF2401_ReadWriteByte(reg);      // select register
        MOV.B   R11, R12
          CFI FunCall NRF2401_ReadWriteByte
        CALLA   #NRF2401_ReadWriteByte
        MOV.B   R12, R8
//   92 	NRF2401_ReadWriteByte(value);             // ..and write value to it..
        MOV.B   R10, R12
          CFI FunCall NRF2401_ReadWriteByte
        CALLA   #NRF2401_ReadWriteByte
//   93 	NRF2401_CSN = 1;                   // CSN high again
        BIS.B   #0x4, &0x263
//   94 	return(status);            // return nRF24L01 status byte
        MOV.B   R8, R12
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
        REQUIRE _A_PDOUT_L
//   95 }
//   96 /***********************************************************************************************
//   97  功能：NRF24L01 写寄存器
//   98  形参：reg: 寄存器
//   99        value:写入的值
//  100  返回：读到的数据
//  101  详解：无
//  102 ************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  103 static uint8_t NRF2401_WriteBuffer(uint8_t reg,uint8_t *pBuf,uint8_t bytes)
NRF2401_WriteBuffer:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function NRF2401_WriteBuffer
//  104 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R11
        MOVA    R13, R8
        MOV.B   R14, R10
//  105 	NRF2401_CSN = 0; 
        BIC.B   #0x4, &0x263
//  106 	uint8_t status = NRF2401_ReadWriteByte(reg);    // Select register to write to and read status byte
        MOV.B   R11, R12
          CFI FunCall NRF2401_ReadWriteByte
        CALLA   #NRF2401_ReadWriteByte
        MOV.B   R12, R9
//  107 	for(uint8_t i=0; i<bytes; i++) // then write all byte in buffer(*pBuf)
        MOV.B   #0x0, R6
??NRF2401_WriteBuffer_0:
        CMP.B   R10, R6
        JC      ??NRF2401_WriteBuffer_1
//  108 	{
//  109 		NRF2401_ReadWriteByte(*pBuf++);
        MOV.B   @R8, R12
          CFI FunCall NRF2401_ReadWriteByte
        CALLA   #NRF2401_ReadWriteByte
        ADDA    #0x1, R8
//  110 	}
        ADD.B   #0x1, R6
        JMP     ??NRF2401_WriteBuffer_0
//  111 	NRF2401_CSN = 1;                 // Set CSN high again
??NRF2401_WriteBuffer_1:
        BIS.B   #0x4, &0x263
//  112 	return(status);          // return nRF24L01 status byte
        MOV.B   R9, R12
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
        REQUIRE _A_PDOUT_L
//  113 }
//  114 /***********************************************************************************************
//  115  功能：NRF24L01 读Buffer
//  116  形参：reg: 寄存器
//  117        pBuf:数据指针
//  118 		 	 bytes: 写入的字节数
//  119  返回：读状态
//  120  详解：无
//  121 ************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  122 static uint8_t NRF2401_ReadBuffer(uint8_t reg,uint8_t *pBuf,uint8_t bytes)
NRF2401_ReadBuffer:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function NRF2401_ReadBuffer
//  123 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R11
        MOVA    R13, R8
        MOV.B   R14, R10
//  124 	NRF2401_CSN = 0;                    		// Set CSN low, init SPI tranaction
        BIC.B   #0x4, &0x263
//  125 	uint8_t status = NRF2401_ReadWriteByte(reg);       		// Select register to write to and read status byte
        MOV.B   R11, R12
          CFI FunCall NRF2401_ReadWriteByte
        CALLA   #NRF2401_ReadWriteByte
        MOV.B   R12, R9
//  126 	for(uint8_t i=0;i<bytes;i++)
        MOV.B   #0x0, R6
??NRF2401_ReadBuffer_0:
        CMP.B   R10, R6
        JC      ??NRF2401_ReadBuffer_1
//  127 	{
//  128 		pBuf[i] = NRF2401_ReadWriteByte(0);    // Perform SPI_RW to read byte from nRF24L01
        MOV.B   #0x0, R12
          CFI FunCall NRF2401_ReadWriteByte
        CALLA   #NRF2401_ReadWriteByte
        MOV.B   R6, R15
        ADDA    R8, R15
        MOV.B   R12, 0(R15)
//  129 	}
        ADD.B   #0x1, R6
        JMP     ??NRF2401_ReadBuffer_0
//  130 	NRF2401_CSN = 1;                           // Set CSN high again
??NRF2401_ReadBuffer_1:
        BIS.B   #0x4, &0x263
//  131 	return(status);                    // return nRF24L01 status byte
        MOV.B   R9, R12
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
        REQUIRE _A_PDOUT_L
//  132 }
//  133 
//  134 /***********************************************************************************************
//  135  功能：检测NRF24L01 是否存在
//  136  形参：
//  137  返回：NRF_OK : 成功   NRF_ERR:失败
//  138  详解：无
//  139 ************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  140 static uint8_t NRF24L01_Check(void)
NRF24L01_Check:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function NRF24L01_Check
//  141 {
        SUB.W   #0x6, SP
          CFI CFA SP+10
//  142 	uint8_t buf[5]={0XA5,0XA5,0XA5,0XA5,0XA5};
        MOV.W   SP, R12
        MOV.W   #`?<Constant {165, 165, 165, 165, 165}>`, R14
        MOV.W   #0x5, R13
          CFI FunCall ?CopyMemoryBytes
        CALLA   #?CopyMemoryBytes
//  143 	NRF2401_WriteBuffer(WRITE_REG+TX_ADDR,buf,5);//写入5个字节的地址.	
        MOV.B   #0x5, R14
        MOV.W   SP, R13
        MOV.B   #0x30, R12
          CFI FunCall NRF2401_WriteBuffer
        CALLA   #NRF2401_WriteBuffer
//  144 	NRF2401_ReadBuffer(TX_ADDR,buf,5); //读出写入的地址  
        MOV.B   #0x5, R14
        MOV.W   SP, R13
        MOV.B   #0x10, R12
          CFI FunCall NRF2401_ReadBuffer
        CALLA   #NRF2401_ReadBuffer
//  145 	for(uint8_t i=0;i < 5;i++)
        MOV.B   #0x0, R14
??NRF24L01_Check_0:
        CMP.B   #0x5, R14
        JC      ??NRF24L01_Check_1
//  146 	{
//  147 		if(buf[i] != 0xA5) return NRF_ERR;
        MOV.B   R14, R15
        ADD.W   SP, R15
        CMP.B   #0xa5, 0(R15)
        JEQ     ??NRF24L01_Check_2
        MOV.B   #0x1, R12
        JMP     ??NRF24L01_Check_3
//  148 	}
??NRF24L01_Check_2:
        ADD.B   #0x1, R14
        JMP     ??NRF24L01_Check_0
//  149 	return NRF_OK;
??NRF24L01_Check_1:
        MOV.B   #0x0, R12
??NRF24L01_Check_3:
        ADD.W   #0x6, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  150 /*******************************************************************************
//  151 *  函数名称：
//  152 *  功能说明：NRF24L01初始化
//  153 *  参数说明：
//  154 *  函数返回：
//  155 *  使用示例：
//  156 ********************************************************************************/}

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  157 uint8_t NRF2401_Init(s_NRF24L01 nrf24l01)
NRF2401_Init:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function NRF2401_Init
//  158 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
//  159         s_nrf24l01 = nrf24l01;
        MOVA    #s_nrf24l01, R12
        MOV.W   SP, R15
        ADD.W   #0x8, R15
        MOV.W   R15, R14
        MOVA    #0xc, R13
          CFI FunCall ?CopyMemoryWords20
        CALLA   #?CopyMemoryWords20
//  160         
//  161         GPIO_Init(NRF2401_CE_PORT,NRF2401_CE_PIN,GPO);
        MOV.W   #0x2, R14
        MOV.W   #0x80, R13
        MOV.B   #0x2, R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//  162         GPIO_Init(NRF2401_CSN_PORT,NRF2401_CSN_PIN,GPO);
        MOV.W   #0x2, R14
        MOV.W   #0x4, R13
        MOV.B   #0x7, R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//  163         //GPIO_Init(NRF2401_IRQ_PORT,NRF2401_IRQ_PIN,GPI);
//  164         
//  165         nrf24l01.CallBack_IRQ_Init();
        MOVA    0xc(SP), R15
          CFI FunCall
        CALLA   R15
//  166 #if NRF24L01HardWareSPI
//  167         NRF2401HardWareSPI_Init();
        PUSH.B  #0x2
          CFI CFA SP+10
        PUSH.B  #0x0
          CFI CFA SP+12
        MOV.B   #0x1, R13
        MOV.W   #0x4b40, R14
        MOV.W   #0x4c, R15
        MOV.B   #0x3, R12
          CFI FunCall SPI_Master_Init
        CALLA   #SPI_Master_Init
//  168 #else
//  169         GPIO_Init(NRF2401_SCL_PORT,NRF2401_SCL_PIN,GPO);
//  170         GPIO_Init(NRF2401_SIMO_PORT,NRF2401_SIMO_PIN,GPO);
//  171         GPIO_Init(NRF2401_SOMI_PORT,NRF2401_SOMI_PIN,GPI);
//  172 #endif
//  173         
//  174 	NRF2401_CSN = 1;			// Spi disable	
        BIS.B   #0x4, &0x263
//  175         NRF2401_CE = 0;			        // chip enable
        BIC.B   #0x80, &0x222
//  176         //检测NRF2401 是否存在
//  177         uint8_t checkStatus = NRF24L01_Check();
          CFI FunCall NRF24L01_Check
        CALLA   #NRF24L01_Check
        MOV.B   R12, R10
//  178         if(checkStatus == NRF_OK)
        ADD.W   #0x4, SP
          CFI CFA SP+8
        CMP.B   #0x0, R10
        JNE     ??NRF2401_Init_0
//  179         {
//  180           NRF2401_CE=0;
        BIC.B   #0x80, &0x222
//  181           
//  182           NRF2401_ReadWriteReg(WRITE_REG+SETUP_AW, ADR_WIDTH - 2);          //设置地址长度为 TX_ADR_WIDTH   	    
        MOV.B   #0x3, R13
        MOV.B   #0x23, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  183           NRF2401_WriteBuffer(WRITE_REG+TX_ADDR,(uint8_t*)TX_ADDRESS,TX_ADR_WIDTH);//写TX节点地址 
        MOV.B   #0x5, R14
        MOVA    #TX_ADDRESS, R13
        MOV.B   #0x30, R12
          CFI FunCall NRF2401_WriteBuffer
        CALLA   #NRF2401_WriteBuffer
//  184           NRF2401_WriteBuffer(WRITE_REG+RX_ADDR_P0,(uint8_t*)RX_ADDRESS,RX_ADR_WIDTH); //设置TX节点地址,主要为了使能ACK	  
        MOV.B   #0x5, R14
        MOVA    #RX_ADDRESS, R13
        MOV.B   #0x2a, R12
          CFI FunCall NRF2401_WriteBuffer
        CALLA   #NRF2401_WriteBuffer
//  185           NRF2401_ReadWriteReg(WRITE_REG+EN_AA,0x01);     //使能通道0的自动应答    
        MOV.B   #0x1, R13
        MOV.B   #0x21, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  186           NRF2401_ReadWriteReg(WRITE_REG+EN_RXADDR,0x01); //使能通道0的接收地址  
        MOV.B   #0x1, R13
        MOV.B   #0x22, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  187           NRF2401_ReadWriteReg(WRITE_REG+RX_PW_P0,RX_PLOAD_WIDTH);//选择通道0的有效数据宽度
        MOV.B   #0x20, R13
        MOV.B   #0x31, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  188           NRF2401_ReadWriteReg(WRITE_REG+SETUP_RETR,0x1a);//设置自动重发间隔时间:500us + 86us;最大自动重发次数:10次
        MOV.B   #0x1a, R13
        MOV.B   #0x24, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  189           NRF2401_ReadWriteReg(WRITE_REG+RF_CH,40);       //设置RF通道为40
        MOV.B   #0x28, R13
        MOV.B   #0x25, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  190           NRF2401_ReadWriteReg(WRITE_REG+RF_SETUP,0x0f);  //设置TX发射参数,0db增益,2Mbps,低噪声增益开启
        MOV.B   #0xf, R13
        MOV.B   #0x26, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  191           NRF2401_ReadWriteReg(WRITE_REG+CONFIG,0x0e);     //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式,开启所有中断
        MOV.B   #0xe, R13
        MOV.B   #0x20, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  192 
//  193           NRF2401_CE=1;//CE为高,10us后启动发送
        BIS.B   #0x80, &0x222
//  194         }
//  195 	return checkStatus;
??NRF2401_Init_0:
        MOV.B   R10, R12
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
        REQUIRE _A_PDOUT_L
        REQUIRE _A_PBOUT_L
//  196 }
//  197 /*******************************************************************************
//  198 *  函数名称：
//  199 *  功能说明：该函数初始化NRF24L01到RX模式
//  200              设置RX地址,写RX数据宽度,选择RF频道,波特率和LNA HCURR
//  201              当CE变高后,即进入RX模式,并可以接收数据了
//  202 *  参数说明：
//  203 *  函数返回：
//  204 *  使用示例：
//  205 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  206 void NRF2401_SetRXMode(void)
NRF2401_SetRXMode:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function NRF2401_SetRXMode
//  207 {
//  208 	NRF2401_CE=0;
        BIC.B   #0x80, &0x222
//  209    
//  210 	NRF2401_ReadWriteReg(WRITE_REG+CONFIG, 0x0f);//配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式
        MOV.B   #0xf, R13
        MOV.B   #0x20, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  211         
//  212 	NRF2401_CE = 1; //CE为高,进入接收模式
        BIS.B   #0x80, &0x222
//  213 }	
        RETA
          CFI EndBlock cfiBlock6
        REQUIRE _A_PBOUT_L
//  214 /*******************************************************************************
//  215 *  函数名称：
//  216 *  功能说明：该函数初始化NRF24L01到TX模式
//  217              设置TX地址,写TX数据宽度,设置RX自动应答的地址,填充TX发送数据,选择RF频道,波特率和LNA HCURR
//  218              PWR_UP,CRC使能
//  219              当CE变高后,即进入RX模式,并可以接收数据了		   
//  220              CE为高大于10us,则启动发送.	
//  221 *  参数说明：
//  222 *  函数返回：
//  223 *  使用示例：
//  224 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  225 void NRF2401_SetTXMode(void)
NRF2401_SetTXMode:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function NRF2401_SetTXMode
//  226 {				
//  227 	NRF2401_CE=0;
        BIC.B   #0x80, &0x222
//  228  
//  229 	NRF2401_ReadWriteReg(WRITE_REG+CONFIG,0x0e);    //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式,开启所有中断
        MOV.B   #0xe, R13
        MOV.B   #0x20, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  230 	
//  231         NRF2401_CE=1;//CE为高,10us后启动发送
        BIS.B   #0x80, &0x222
//  232 }
        RETA
          CFI EndBlock cfiBlock7
        REQUIRE _A_PBOUT_L
//  233 /*******************************************************************************
//  234 *  函数名称：
//  235 *  功能说明：启动NRF24L01发送一次数据
//  236 *  参数说明：txbuf:待发送数据首地址
//  237 *  函数返回：返回值:发送完成状况
//  238 *  使用示例：
//  239 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  240 void NRF2401_SendData(uint8_t *txbuf)
NRF2401_SendData:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function NRF2401_SendData
//  241 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        MOVA    R12, R10
//  242 	/*uint8_t sta;
//  243 	NRF2401_CE=0;
//  244 	NRF2401_WriteBuffer(WR_TX_PLOAD,txbuf,TX_PLOAD_WIDTH);//写数据到TX BUF  32个字节
//  245  	NRF2401_CE=1;//启动发送	  
//  246 	while(NRF2401_IRQ!=0);//等待发送完成
//  247 	sta = NRF2401_ReadWriteReg(STATUS,0xFF);  //读取状态寄存器的值	
//  248 	NRF2401_ReadWriteReg(WRITE_REG+STATUS,sta); //清除TX_DS或MAX_RT中断标志
//  249 	
//  250 	if(sta & MAX_TX)//达到最大重发次数
//  251 	{
//  252 		NRF2401_ReadWriteReg(FLUSH_TX,0xff);//清除TX FIFO寄存器 
//  253 		return MAX_TX; 
//  254 	}
//  255 	if(sta & TX_OK)//发送完成
//  256 	{
//  257 		return TX_OK;
//  258 	}
//  259 	return 0xff;//其他原因发送失败
//  260         */
//  261         NRF2401_CE = 0;			//StandBy I模式	
        BIC.B   #0x80, &0x222
//  262         
//  263 	NRF2401_WriteBuffer(WR_TX_PLOAD, txbuf, TX_PLOAD_WIDTH); 			 // 装载数据	
        MOV.B   #0x20, R14
        MOVA    R10, R13
        MOV.B   #0xa0, R12
          CFI FunCall NRF2401_WriteBuffer
        CALLA   #NRF2401_WriteBuffer
//  264         NRF2401_ReadWriteReg(WRITE_REG+STATUS,STATUS_TX_DS|STATUS_MAX_RT); //清除TX_DS或MAX_RT中断标志
        MOV.B   #0x30, R13
        MOV.B   #0x27, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  265         
//  266         NRF2401_CE = 1;		 //置高CE，激发数据发送
        BIS.B   #0x80, &0x222
//  267 }
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
        REQUIRE _A_PBOUT_L
//  268 /*******************************************************************************
//  269 *  函数名称：
//  270 *  功能说明：启动NRF24L01发送一次数据
//  271 *  参数说明：txbuf:待发送数据首地址
//  272 *  函数返回：返回值:0，接收完成；其他，错误代码
//  273 *  使用示例：
//  274 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  275 uint8_t NRF2401_RecData(uint8_t *rxbuf)
NRF2401_RecData:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function NRF2401_RecData
//  276 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOVA    R12, R10
//  277 	uint8_t status = NRF2401_ReadWriteReg(STATUS,0xFF);  //读取状态寄存器的值    	 
        MOV.B   #0xff, R13
        MOV.B   #0x7, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
        MOV.B   R12, R11
//  278 	NRF2401_ReadWriteReg(WRITE_REG+STATUS,status); //清除TX_DS或MAX_RT中断标志
        MOV.B   R11, R13
        MOV.B   #0x27, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  279         if(status & RX_OK)//接收到数据
        BIT.B   #0x40, R11
        JNC     ??NRF2401_RecData_0
//  280 	{
//  281 		NRF2401_ReadBuffer(RD_RX_PLOAD,rxbuf,RX_PLOAD_WIDTH);//读取数据
        MOV.B   #0x20, R14
        MOVA    R10, R13
        MOV.B   #0x61, R12
          CFI FunCall NRF2401_ReadBuffer
        CALLA   #NRF2401_ReadBuffer
//  282 		NRF2401_ReadWriteReg(FLUSH_RX,0xff);//清除RX FIFO寄存器 
        MOV.B   #0xff, R13
        MOV.B   #0xe2, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  283 		return RX_OK; 
        MOV.B   #0x40, R12
        JMP     ??NRF2401_RecData_1
//  284 	}   
//  285 	return 0xff;//没收到任何数据
??NRF2401_RecData_0:
        MOV.B   #0xff, R12
??NRF2401_RecData_1:
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
//  286 }
//  287 /*******************************************************************************
//  288 *  函数名称：
//  289 *  功能说明：NRF24L01中断处理函数，请在中断中添加该函数
//  290 *  参数说明：
//  291 *  函数返回：
//  292 *  使用示例：
//  293 ********************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  294 void  NRF2401_IRQ_Handler()
NRF2401_IRQ_Handler:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function NRF2401_IRQ_Handler
//  295 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
//  296     /*读取status寄存器的值  */
//  297     uint8_t state = NRF2401_ReadWriteReg(STATUS,0xFF);  //读取状态寄存器的值   
        MOV.B   #0xff, R13
        MOV.B   #0x7, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
        MOV.B   R12, R10
//  298     if(state & STATUS_RX_DR) //接收到数据
        BIT.B   #0x40, R10
        JNC     ??NRF2401_IRQ_Handler_0
//  299     {
//  300        NRF2401_CE = 0;			//StandBy I模式	
        BIC.B   #0x80, &0x222
//  301        if(s_nrf24l01.CallBack_RecevieData != NULL)
        MOVA    &s_nrf24l01 + 8, R15
        CMPA    #0x0, R15
        JEQ     ??NRF2401_IRQ_Handler_1
//  302        {
//  303           NRF2401_ReadBuffer(RD_RX_PLOAD,(uint8_t *)s_nrf24l01.pReceiveData,RX_PLOAD_WIDTH);//读取数据
        MOV.B   #0x20, R14
        MOVA    &s_nrf24l01, R13
        MOV.B   #0x61, R12
          CFI FunCall NRF2401_ReadBuffer
        CALLA   #NRF2401_ReadBuffer
//  304           s_nrf24l01.CallBack_RecevieData();
          CFI FunCall
        CALLA   &s_nrf24l01 + 8
//  305        }
//  306        NRF2401_ReadWriteReg(FLUSH_RX,0xff);//清除RX FIFO寄存器 
??NRF2401_IRQ_Handler_1:
        MOV.B   #0xff, R13
        MOV.B   #0xe2, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  307        NRF2401_CE = 1;		 //置高CE，激发数据发送
        BIS.B   #0x80, &0x222
//  308     }
//  309 
//  310     if(state & STATUS_TX_DS) //发送完数据
??NRF2401_IRQ_Handler_0:
        BIT.B   #0x20, R10
        JNC     ??NRF2401_IRQ_Handler_2
//  311     {
//  312         if(s_nrf24l01.CallBack_SendDataOk != NULL)
        MOVA    &s_nrf24l01 + 12, R15
        CMPA    #0x0, R15
        JEQ     ??NRF2401_IRQ_Handler_2
//  313         {
//  314           s_nrf24l01.CallBack_SendDataOk();
          CFI FunCall
        CALLA   &s_nrf24l01 + 12
//  315         }
//  316     }
//  317 
//  318     if(state & STATUS_MAX_RT)      //发送超时
??NRF2401_IRQ_Handler_2:
        BIT.B   #0x10, R10
        JNC     ??NRF2401_IRQ_Handler_3
//  319     {
//  320         if(s_nrf24l01.CallBack_SendOutTime != NULL)
        MOVA    &s_nrf24l01 + 16, R15
        CMPA    #0x0, R15
        JEQ     ??NRF2401_IRQ_Handler_4
//  321         {
//  322            s_nrf24l01.CallBack_SendOutTime();
          CFI FunCall
        CALLA   &s_nrf24l01 + 16
//  323         }
//  324         NRF2401_ReadWriteReg(FLUSH_TX,0xff);//清除TX FIFO寄存器
??NRF2401_IRQ_Handler_4:
        MOV.B   #0xff, R13
        MOV.B   #0xe1, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  325     }
//  326 
//  327     if(state & STATUS_TX_FULL) //TX FIFO 满
??NRF2401_IRQ_Handler_3:
        BIT.B   #0x1, R10
        JNC     ??NRF2401_IRQ_Handler_5
//  328     {
//  329         if(s_nrf24l01.CallBack_TxFull != NULL)
        MOVA    &s_nrf24l01 + 20, R15
        CMPA    #0x0, R15
        JEQ     ??NRF2401_IRQ_Handler_5
//  330         {
//  331            s_nrf24l01.CallBack_TxFull();
          CFI FunCall
        CALLA   &s_nrf24l01 + 20
//  332         }
//  333     }
//  334     NRF2401_ReadWriteReg(WRITE_REG+STATUS,state); //清除TX_DS或MAX_RT中断标志
??NRF2401_IRQ_Handler_5:
        MOV.B   R10, R13
        MOV.B   #0x27, R12
          CFI FunCall NRF2401_ReadWriteReg
        CALLA   #NRF2401_ReadWriteReg
//  335 }
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
        REQUIRE _A_PBOUT_L

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant {165, 165, 165, 165, 165}>`:
        DC8 165, 165, 165, 165, 165

        END
//  336 
//  337 
// 
// 786 bytes in segment CODE
//   4 bytes in segment DATA16_AN
//   5 bytes in segment DATA16_C
//  10 bytes in segment DATA20_C
//  24 bytes in segment DATA20_Z
// 
// 786 bytes of CODE  memory
//  15 bytes of CONST memory
//  24 bytes of DATA  memory (+ 4 bytes shared)
//
//Errors: none
//Warnings: none
